<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhythmic-zone.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":false,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="常见的编译型语言如C，C++，这种类型的语言会直接把代码编译成CPU所能理解的机器码。而java为了实现一次编译，到处运行的特性，把编译过程分成两部分：先将代码编译成字节码，然后再由解释器将字节码翻译成机器码。所以性能上对比编译型语言有所欠缺。">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm即时编译">
<meta property="og:url" content="https://rhythmic-zone.github.io/2020/10/15/develop/jvm%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/index.html">
<meta property="og:site_name" content="rhythmic-zone">
<meta property="og:description" content="常见的编译型语言如C，C++，这种类型的语言会直接把代码编译成CPU所能理解的机器码。而java为了实现一次编译，到处运行的特性，把编译过程分成两部分：先将代码编译成字节码，然后再由解释器将字节码翻译成机器码。所以性能上对比编译型语言有所欠缺。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit1.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit2.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit3.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit4.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit5.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit6.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit7.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit8.png">
<meta property="og:image" content="https://rhythmic-zone.github.io/images/jit9.png">
<meta property="article:published_time" content="2020-10-15T08:44:49.000Z">
<meta property="article:modified_time" content="2021-03-19T02:52:33.133Z">
<meta property="article:author" content="blue">
<meta property="article:tag" content="java,工具,生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rhythmic-zone.github.io/images/jit1.png">

<link rel="canonical" href="https://rhythmic-zone.github.io/2020/10/15/develop/jvm%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>jvm即时编译 | rhythmic-zone</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rhythmic-zone</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rhythmic-zone.github.io/2020/10/15/develop/jvm%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blue">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rhythmic-zone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm即时编译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-15 16:44:49" itemprop="dateCreated datePublished" datetime="2020-10-15T16:44:49+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-19 10:52:33" itemprop="dateModified" datetime="2021-03-19T10:52:33+08:00">2021-03-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>常见的编译型语言如C，C++，这种类型的语言会直接把代码编译成CPU所能理解的机器码。而java为了实现<em>一次编译，到处运行</em>的特性，把编译过程分成两部分：先将代码编译成字节码，然后再由解释器将字节码翻译成机器码。所以性能上对比编译型语言有所欠缺。</p>
<span id="more"></span>
<p>为了优化java性能，jvm在解释器之外引入了即时编译器（Just In Time)：当程序运行时，解释器先发挥作用，代码可以直接运行。随者时间推移，即时编译器逐渐发挥作用，把越来越多的代码翻译成本地代码，来获取更高的执行效率。这时的解释器可以作为降级手段，在一些不可靠的编译优化出现问题时，将切回解释执行，保证程序正常运行。</p>
<p>即时编译器极大提高了Java程序的运行速度，而且与静态编译相比，即时编译器可以选择性的编译热点代码，省去很多编译时间，也节省很多空间，目前即时编译器已经非常成熟，在性能上可以与编译型语言相比。</p>
<h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>java执行过程整体可以分成两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析，语法分析，语义分析，编译原理中这部分称之为前端编译。接下来无需编译，直接逐条将字节码解释执行，在解释过程中，虚拟机同时对运行信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会对后端编译-将字节码翻译成机器码，但不是所有代码都会被编译，只有jvm认定为热点代码，才可能被编译。</p>
<p>怎么样才被认定为热点代码？jvm中会设置一个阈值，当方法或者代码块在一定时间内超过这个阈值，就会被编译，存入code cache，当下次执行时，再次遇到这段代码，就会从code cache中读取机器码，直接执行，以此提升程序运行性能，如图所示<br><img src="/images/jit1.png" alt=""></p>
<h2 id="jvm编译器"><a href="#jvm编译器" class="headerlink" title="jvm编译器"></a>jvm编译器</h2><p>jvm中集成了两种编译器，Client Compiler和Server Compiler，他们的作用也不。Client Compiler注重于启动速度和局部优化，一般用于客户端，Server Compiler则更关注全局的优化，性能更好，但由于会进行更多的全局分析，所以启动速度会变慢。</p>
<h3 id="Client-Compiler"><a href="#Client-Compiler" class="headerlink" title="Client Compiler"></a>Client Compiler</h3><p>HotSpot VM带有一个Client Compiler，C1编译器。这种编译器启动速度非常快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</p>
<ul>
<li>局部简单可靠的优化，比如字节码上进行一些基础优化，方法内联，常量传播等，放弃许多耗时较长的全局优化</li>
<li>将字节码构造成高级中间表示（High-level Intermediate Representation) ,HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化</li>
<li>最后将HIR转换成低级中间表示（Low-level Intermediate Representation），在LIR的基础上会进行寄存器分配，窥孔优化（局部的优化方式，编译器在一个基本块或者多个基础块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体分析，进行指令转换，来提升代码性能），最终生成机器码</li>
</ul>
<h3 id="Server-Compiler"><a href="#Server-Compiler" class="headerlink" title="Server Compiler"></a>Server Compiler</h3><p>Server Compiler主要关注一些编译耗时较长的全局优化，甚至会根据程序运行信息进行一些不可靠的激进优化。这种编译器启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高<code>30%</code>以上。目前Hot Spot虚拟机使用的Server Compiler有两种，C2和Graal</p>
<h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2编译器在进行编译优化时，会使用一种控制流和数据流结合的图数据结构，称为Ideal Graph，表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其涉及浮动代码块的优化）变得不那么复杂。</p>
<p>Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令优化，比如Global Value Numbering，常量折叠等，解析结束后还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局优化，这个阶段如果JVM判定没有全局优化的必要，则会跳过这个步骤。</p>
<p>无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph,最后编译的机器码就是从MachNode Graph中得到，生成的机器码前还会有一些包括寄存器分配，窥孔优化等操作。<br><img src="/images/jit2.png" alt=""></p>
<h4 id="Graal-Compiler"><a href="#Graal-Compiler" class="headerlink" title="Graal Compiler"></a>Graal Compiler</h4><p>从JDK9开始，HotSpot虚拟机集成了一种新的Server Compiler：Graal编译器。相比C2，Graal有这几种关键特性</p>
<ul>
<li>Graal会更侧重于分支预测等激进优化</li>
<li>使用Java编写，对于新特性如Lambda,Stream支持更友好</li>
<li>更深层次的优化，如虚函数内联，部分逃逸分析等</li>
</ul>
<p>当前还处于实验状态，启用方式： <code>-XX:+UnlockExperimentalVMOptions -X:+UseJVMCICompiler</code></p>
<h1 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h1><p>在java7之前，需要研发人员根据服务性质去选择编译器，对于需要快速启动的或者不太长时间运行的服务，可以选择C1，长时间运行的服务或者对于峰值有要求的后台服务，可以采用峰值性能更好的C2.java7开始引入了分层编译概念，结合了C1和C2优势，追求启动速度和峰值性能的一个平衡。编译器将JVM执行分成了五个层级：</p>
<ol start="0">
<li>解释执行</li>
<li>执行不带Profiling的C1代码</li>
<li>执行仅带方法调用次数以及循环回边次数Profiling的C1代码</li>
<li>执行带所有Profiling的C1代码</li>
<li>执行C2代码</li>
</ol>
<p>Profiling就是能够收集反应程序执行状态的数据。其中基础的统计数据就是方法的调用次数以及循环回边的执行次数。</p>
<p>通常情况下，C2代码的执行效率要比C1代码高出30以上，C1层执行的代码，按执行效率排序高至低则是<code>1&gt;2&gt;3</code>，在五层中1，4都是处于终止状态，当一个方法达到终止状态后，只要编译后的代码没有失效，那么JVM就不会再次发出该方法的编译请求。服务实际运行时。JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。<br><img src="/images/jit3.png" alt=""></p>
<ul>
<li>图中第一条路径，代码一般编译情况，热点方法从解释执行到3层的C1编译，最后被第四层编译</li>
<li>如果方法比较小(getter/setter)，三层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1,C2的执行效率相同，就会执行途中2这条路径，在这种情况下，JVM在三层编译后会放弃C2编译</li>
<li>在C1忙碌的情况下，执行途中3路径，在解释过程中对程序Profiling，根据信息直接选择C2编译</li>
<li>在C2忙碌的情况下会先选择二层的编译，再选择三层的编译，以减少三层的执行时间</li>
<li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行中发现预测错误，这时会进行反优化，重新进入解释执行</li>
</ul>
<p>总的来说C1编译速度快，C2编译质量高，分层编译的不同编译路径，也就是根据程序运行情况来寻找当前服务的最佳平衡点，从JDK8开始，JVM默认分层编译</p>
<h2 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h2><p>JVM根据方法调用次数以及循环回边执行次数来触发即时编译。循环回边时一个控制流中的概念，在程序中可以简单理解成往回跳转的代码，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(Object obj) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 200; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该代码经过编译生成如下字节码。其中偏移量为18的字节码将往回跳至偏移量为4的字节码中，在解释执行时，没运行一次该指令，JVM会将该方法的循环回边加1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: sipush        200</span><br><span class="line">       8: if_icmpge     21</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: iload_2</span><br><span class="line">      13: iadd</span><br><span class="line">      14: istore_1</span><br><span class="line">      15: iinc          2, 1</span><br><span class="line">      18: goto          4</span><br><span class="line">      21: return</span><br></pre></td></tr></table></figure><br>在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。当方法的调用次数和循环回边的次数的和，超过由参数<code>-XX:CompileThreshold</code>指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</p>
<p>开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：<br>方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</p>
<p>方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</p>
<h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><p>即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</p>
<h2 id="中间表达形式"><a href="#中间表达形式" class="headerlink" title="中间表达形式"></a>中间表达形式</h2><p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p>
<p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a &#x3D; 1;</span><br><span class="line">  a &#x3D; 2;</span><br><span class="line">  b &#x3D; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a_1 &#x3D; 1;</span><br><span class="line">  a_2 &#x3D; 2;</span><br><span class="line">  b_1 &#x3D; a_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</p>
<p>除此之外，SSA IR对其他优化方式也有很大的帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a &#x3D; 2;</span><br><span class="line">  int b &#x3D; 0</span><br><span class="line">  if(2 &gt; 1)&#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    b &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到SSA IR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_1 &#x3D; 2;</span><br><span class="line">b_1 &#x3D; 0</span><br><span class="line">if true:</span><br><span class="line">  a_2 &#x3D; 1;</span><br><span class="line">else</span><br><span class="line">  b_2 &#x3D; 2;</span><br><span class="line">add(a,b)</span><br></pre></td></tr></table></figure><br>编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a &#x3D; 1;</span><br><span class="line">  int b &#x3D; 0;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的</p>
<h2 id="C1中的中间表达形式"><a href="#C1中的中间表达形式" class="headerlink" title="C1中的中间表达形式"></a>C1中的中间表达形式</h2><p>HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：<br><img src="/images/jit4.png" alt=""></p>
<p>其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</p>
<p>从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字节码                     Local Value             operand stack              HIR</span><br><span class="line"> 5: iload_1                  [i1,i2]                 [i1]</span><br><span class="line"> 6: iload_2                  [i1,i2]                 [i1,i2]   </span><br><span class="line">                             ................................................   i3: i1 * i2</span><br><span class="line"> 7: imul                                   </span><br><span class="line"> 8: istore_3                 [i1,i2，i3]              [i3]</span><br></pre></td></tr></table></figure><br>可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。<br>C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</p>
<h3 id="Sea-of-Nodes-IR"><a href="#Sea-of-Nodes-IR" class="headerlink" title="Sea-of-Nodes IR"></a>Sea-of-Nodes IR</h3><p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int foo(int count) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对应IR如下<br><img src="/images/jit5.png" alt=""></p>
<p>图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</p>
<p>这种图具有轻量级的边结构。图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</p>
<p>依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</p>
<h3 id="Phi-And-Region-Nodes"><a href="#Phi-And-Region-Nodes" class="headerlink" title="Phi And Region Nodes"></a>Phi And Region Nodes</h3><p>Ideal Graph是SSA IR。由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">  if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    a &#x3D; 5;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a &#x3D; 6;</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：<br><img src="/images/jit6.png" alt=""></p>
<p>Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">  a_1 &#x3D; 0;</span><br><span class="line">  if(x &#x3D;&#x3D; 1)&#123;</span><br><span class="line">    a_2 &#x3D; 5;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    a_3 &#x3D; 6;</span><br><span class="line">  &#125;</span><br><span class="line">  a_4 &#x3D; Phi(a_2,a_3);</span><br><span class="line">  return a_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Global-Value-Numbering"><a href="#Global-Value-Numbering" class="headerlink" title="Global Value Numbering"></a>Global Value Numbering</h3><p>Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</p>
<p>GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1;</span><br><span class="line">b &#x3D; 2;</span><br><span class="line">c &#x3D; a + b;</span><br><span class="line">d &#x3D; a + b;</span><br><span class="line">e &#x3D; d;</span><br></pre></td></tr></table></figure><br>GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。</p>
<p>可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</p>
<p>Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean flag &#x3D; true;</span><br><span class="line">public static int value0 &#x3D; 0;</span><br><span class="line">public static int value1 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">public static int foo(int value) &#123;</span><br><span class="line">    int result &#x3D; bar(flag);</span><br><span class="line">    if (result !&#x3D; 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int bar(boolean flag) &#123;</span><br><span class="line">    return flag ? value0 : value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jit7.png" alt=""><br>内联后的IR图：<br><img src="/images/jit8.png" alt=""></p>
<p>内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</p>
<ul>
<li>被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</li>
<li>调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</li>
<li>如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</li>
</ul>
<h4 id="方法内联的条件"><a href="#方法内联的条件" class="headerlink" title="方法内联的条件"></a>方法内联的条件</h4><p>编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</p>
<p>可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：<br><img src="/images/jit9.png" alt=""></p>
<h4 id="虚函数内联"><a href="#虚函数内联" class="headerlink" title="虚函数内联"></a>虚函数内联</h4><p>内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</p>
<p>C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj &#x3D; new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 &#x3D; new VirtualInvoke1();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000113369d37: callq  0x00000001132950a0  ; OopMap&#123;off&#x3D;476&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  &#x2F;&#x2F;代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 18)</span><br><span class="line">                                               ;   &#123;optimized virtual_call&#125;  &#x2F;&#x2F;虚调用已经被优化</span><br></pre></td></tr></table></figure><br>可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：<br>对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。<br>对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</p>
<p>逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      example();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void example() &#123;</span><br><span class="line">      Foo foo &#x3D; new Foo();</span><br><span class="line">      Bar bar &#x3D; new Bar();</span><br><span class="line">      bar.setFoo(foo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line">  class Bar &#123;</span><br><span class="line">    private Foo foo;</span><br><span class="line">    public void setFoo(Foo foo) &#123;</span><br><span class="line">      this.foo &#x3D; foo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</p>
<p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。</p>
<p>这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    Cat cat &#x3D; new Cat(1,10);</span><br><span class="line">    addAgeAndWeight(cat.age,Cat.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    int age &#x3D; 1;</span><br><span class="line">    int weight &#x3D; 10;</span><br><span class="line">    addAgeAndWeight(age,weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="部分逃逸分析"><a href="#部分逃逸分析" class="headerlink" title="部分逃逸分析"></a>部分逃逸分析</h4><p>部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</p>
<h3 id="Loop-Transformations"><a href="#Loop-Transformations" class="headerlink" title="Loop Transformations"></a>Loop Transformations</h3><p>C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离</p>
<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段</p>
<p>循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i &#x3D; 0;i&lt;200;i++)&#123;</span><br><span class="line">    delete(i);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i &#x3D; 0;i&lt;200;i+&#x3D;5)&#123;</span><br><span class="line">    delete(i);</span><br><span class="line">    delete(i+1);</span><br><span class="line">    delete(i+2);</span><br><span class="line">    delete(i+3);</span><br><span class="line">    delete(i+4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</p>
<h3 id="循环分离"><a href="#循环分离" class="headerlink" title="循环分离"></a>循环分离</h3><p>循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">for(int i &#x3D; 0;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] &#x3D; x[i] + x[a];</span><br><span class="line">  a &#x3D; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[0] &#x3D; x[0] + 10;</span><br><span class="line">for(int i &#x3D; 1;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] &#x3D; x[i] + x[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</p>
<h3 id="窥孔优化与寄存器分配"><a href="#窥孔优化与寄存器分配" class="headerlink" title="窥孔优化与寄存器分配"></a>窥孔优化与寄存器分配</h3><p>窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1&#x3D;x1*3  经过强度削减后得到  y1&#x3D;(x1&lt;&lt;1)+x1</span><br></pre></td></tr></table></figure></p>
<p>编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</p>
<p>寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</p>
<p>寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/15/develop/innodb/double%20write/" rel="prev" title="innodb两次写">
      <i class="fa fa-chevron-left"></i> innodb两次写
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/15/develop/RDD/" rel="next" title="RDD">
      RDD <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">jvm编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-Compiler"><span class="nav-number">1.1.1.</span> <span class="nav-text">Client Compiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-Compiler"><span class="nav-number">1.1.2.</span> <span class="nav-text">Server Compiler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C2"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">C2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Graal-Compiler"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Graal Compiler</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="nav-number">2.</span> <span class="nav-text">分层编译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="nav-number">2.1.</span> <span class="nav-text">即时编译的触发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">编译优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">中间表达形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C1%E4%B8%AD%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">C1中的中间表达形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sea-of-Nodes-IR"><span class="nav-number">3.2.1.</span> <span class="nav-text">Sea-of-Nodes IR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phi-And-Region-Nodes"><span class="nav-number">3.2.2.</span> <span class="nav-text">Phi And Region Nodes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Global-Value-Numbering"><span class="nav-number">3.2.3.</span> <span class="nav-text">Global Value Numbering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="nav-number">3.2.4.</span> <span class="nav-text">方法内联</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">方法内联的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">虚函数内联</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">3.2.5.</span> <span class="nav-text">逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">栈上分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">部分逃逸分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loop-Transformations"><span class="nav-number">3.2.6.</span> <span class="nav-text">Loop Transformations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="nav-number">3.2.7.</span> <span class="nav-text">循环展开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%86%E7%A6%BB"><span class="nav-number">3.2.8.</span> <span class="nav-text">循环分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E9%85%8D"><span class="nav-number">3.2.9.</span> <span class="nav-text">窥孔优化与寄存器分配</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">blue</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">blue</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
