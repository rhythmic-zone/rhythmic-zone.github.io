<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LinkedBlockingQueue中的并发控制</title>
      <link href="2022/11/04/develop/LinkedBlockingQueue%E4%B8%AD%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BB%86%E8%8A%82/"/>
      <url>2022/11/04/develop/LinkedBlockingQueue%E4%B8%AD%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>一般来说保证共享变量的多线程并发读写安全需要用同一把锁来控制，但是LinkedBlockingQueue有putLock, takeLock两把锁，那这是如何保证并发并发安全的？</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一般来说保证共享变量的多线程并发读写安全需要用同一把锁来控制，但LinkedBlockingQueue采用“two lock queue”算法变体，双锁（ReentrantLock）：takeLock、putLock，允许读写并行，那这是如何保证多线程并发安全的？</p><h1 id="two-lock-queue算法"><a href="#two-lock-queue算法" class="headerlink" title="two lock queue算法"></a>two lock queue算法</h1><p>这是Maged M. Michael和Michael L. Scott在1996发表论文中<a href="https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking</a>提到的一种算法。</p><p>为了提高并发队列的性能，他们提出一种lock free无锁算法(基于cas)。但是在某些不支持cas指令的及其上，同样给出了优化方案，也就是two lock queue 算法</p><h1 id="为什么要用两把锁"><a href="#为什么要用两把锁" class="headerlink" title="为什么要用两把锁"></a>为什么要用两把锁</h1><p>如果用同一把锁，不管是enqueue入队操作和dequeue出队操作，都需要获取这把唯一的排他锁，在高并发下容易引起激烈竞争从而导致性能下降。从queue的特性考虑：</p><ul><li>enqueue: 总是在队列尾部插入节点</li><li>dequeue：总是在队列头部删除节点</li></ul><p>在这个过程中，enqueue和dequeue在大部分情况下都是相互独立的，并没有发生冲突，也就无需锁住整个队列。参照hashmap1.8之前的锁优化方式，队列头尾分别用不同的锁就可以极大降低冲突概率。但从中会有需要考虑一些临界值的处理：</p><ul><li>在一个空队列里插入一个节点</li><li>只最后一个节点时出队列<br>正常情况下面对这两种情况可能需要同时操作两把锁，这就容易发生死锁及性能下降。下面是论文中对这个情况的处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">structure node_t &#123;value: data type, next: pointer to node_t&#125;</span><br><span class="line"> structure queue_t &#123;Head: pointer to node_t, Tail: pointer to node_t,</span><br><span class="line">                       H_lock: lock type, T_lock: lock type&#125;</span><br><span class="line"> </span><br><span class="line"> initialize(Q: pointer to queue_t)</span><br><span class="line">    node &#x3D; new_node()&#x2F;&#x2F; Allocate a free node</span><br><span class="line">    node-&gt;next &#x3D; NULL          &#x2F;&#x2F; Make it the only node in the linked list</span><br><span class="line">    Q-&gt;Head &#x3D; Q-&gt;Tail &#x3D; node&#x2F;&#x2F; Both Head and Tail point to it</span><br><span class="line">    Q-&gt;H_lock &#x3D; Q-&gt;T_lock &#x3D; FREE&#x2F;&#x2F; Locks are initially free</span><br><span class="line"> </span><br><span class="line"> enqueue(Q: pointer to queue_t, value: data type)</span><br><span class="line">    node &#x3D; new_node()        &#x2F;&#x2F; Allocate a new node from the free list</span><br><span class="line">    node-&gt;value &#x3D; value&#x2F;&#x2F; Copy enqueued value into node</span><br><span class="line">    node-&gt;next &#x3D; NULL          &#x2F;&#x2F; Set next pointer of node to NULL</span><br><span class="line">    lock(&amp;Q-&gt;T_lock)&#x2F;&#x2F; Acquire T_lock in order to access Tail</span><br><span class="line">       Q-&gt;Tail-&gt;next &#x3D; node&#x2F;&#x2F; Link node at the end of the linked list</span><br><span class="line">       Q-&gt;Tail &#x3D; node&#x2F;&#x2F; Swing Tail to node</span><br><span class="line">    unlock(&amp;Q-&gt;T_lock)&#x2F;&#x2F; Release T_lock</span><br><span class="line"> </span><br><span class="line"> dequeue(Q: pointer to queue_t, pvalue: pointer to data type): boolean</span><br><span class="line">    lock(&amp;Q-&gt;H_lock)        &#x2F;&#x2F; Acquire H_lock in order to access Head</span><br><span class="line">       node &#x3D; Q-&gt;Head&#x2F;&#x2F; Read Head</span><br><span class="line">       new_head &#x3D; node-&gt;next&#x2F;&#x2F; Read next pointer</span><br><span class="line">       if new_head &#x3D;&#x3D; NULL&#x2F;&#x2F; Is queue empty?</span><br><span class="line">          unlock(&amp;Q-&gt;H_lock)&#x2F;&#x2F; Release H_lock before return</span><br><span class="line">          return FALSE&#x2F;&#x2F; Queue was empty</span><br><span class="line">       endif</span><br><span class="line">       *pvalue &#x3D; new_head-&gt;value&#x2F;&#x2F; Queue not empty.  Read value before release</span><br><span class="line">       Q-&gt;Head &#x3D; new_head&#x2F;&#x2F; Swing Head to next node</span><br><span class="line">    unlock(&amp;Q-&gt;H_lock)&#x2F;&#x2F; Release H_lock</span><br><span class="line">    free(node)&#x2F;&#x2F; Free node</span><br><span class="line">    return TRUE&#x2F;&#x2F; Queue was not empty, dequeue succeeded</span><br></pre></td></tr></table></figure>可以看到：队列初始化的时候创建了一个空节点，这样在首次入队的时候，队列就不是空队列，无需修改head指针，剩下一个元素的时候也无需修改tail指针，避开了同时修改头尾指针的情况。<br>但假设是个空列表，两个线程分别操作enqueue及dequeue，因为是用两把锁分别控制的，那可能存在入队后未释放锁之前，另一个线程可能取不到最新的node。既然可能存在这个问题，那在linkedBlockQueue中是如何处理的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   public boolean offer(E e) &#123;</span><br><span class="line">       if (e &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">       final AtomicInteger count &#x3D; this.count;</span><br><span class="line">       if (count.get() &#x3D;&#x3D; capacity)</span><br><span class="line">           return false;</span><br><span class="line">       final int c;</span><br><span class="line">       final Node&lt;E&gt; node &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">       final ReentrantLock putLock &#x3D; this.putLock;</span><br><span class="line">       putLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           if (count.get() &#x3D;&#x3D; capacity)</span><br><span class="line">               return false;</span><br><span class="line">           enqueue(node);</span><br><span class="line">           c &#x3D; count.getAndIncrement();</span><br><span class="line">           if (c + 1 &lt; capacity)</span><br><span class="line">               notFull.signal();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       if (c &#x3D;&#x3D; 0)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public E poll() &#123;</span><br><span class="line">       final AtomicInteger count &#x3D; this.count;</span><br><span class="line">       if (count.get() &#x3D;&#x3D; 0)</span><br><span class="line">           return null;</span><br><span class="line">       final E x;</span><br><span class="line">       final int c;</span><br><span class="line">       final ReentrantLock takeLock &#x3D; this.takeLock;</span><br><span class="line">       takeLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           if (count.get() &#x3D;&#x3D; 0)</span><br><span class="line">               return null;</span><br><span class="line">           x &#x3D; dequeue();</span><br><span class="line">           c &#x3D; count.getAndDecrement();</span><br><span class="line">           if (c &gt; 1)</span><br><span class="line">               notEmpty.signal();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           takeLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       if (c &#x3D;&#x3D; capacity)</span><br><span class="line">           signalNotFull();</span><br><span class="line">       return x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>这两段逻辑跟论文中的伪代码逻辑基本一致，那如果有刚提过的可见性问题，那图中就可能存在npe，不过对于官方并发包来说不可能存在这种问题。<br>这在源码中也有解释，从注释中可以看到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Visibility between writers and readers is provided as follows:</span><br><span class="line">*</span><br><span class="line">* Whenever an element is enqueued, the putLock is acquired and</span><br><span class="line">* count updated.  A subsequent reader guarantees visibility to the</span><br><span class="line">* enqueued Node by either acquiring the putLock (via fullyLock)</span><br><span class="line">* or by acquiring the takeLock, and then reading n &#x3D; count.get();</span><br><span class="line">* this gives visibility to the first n items.</span><br></pre></td></tr></table></figure>可见性保证有两种方式</li><li>获取putLock</li><li>获取take lock后，通过n= count.get()保证可见性</li></ul><p>第一点很好理解，也就是同时获取两把锁，那第二点是如何保证的？<br>用两把锁无法保证可见性的原因是两个线程都只在自己的工作内存中操作，没有及时写入到主存。因为n是AtomicInteger类型，内部是一个volatile修饰的变量</p><ul><li>保证被修饰的变量对所有线程可见</li><li>禁止重排序<br>这里其实有个隐性规则：该变量的写操作会引起别的CPU或者别的内核无效化其Cache<br>所以在更新完链表并修改count值后，对应的node也可以读取到，其他线程可根据count值来保证可见性</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>graphql</title>
      <link href="2021/12/20/develop/graphql/%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/12/20/develop/graphql/%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>graphql是用于API查询语言，是一个基于类型系统来执行查询的服务端。graphql没有和任何特定的数据库及存储引擎绑定，而是依靠现有代码和数据支撑。</p><span id="more"></span><p>一个graphql服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的字段提供解析函数。例如查询当前登录用户，那这个查询语句可能如下展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">    user: User </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">    id: ID</span><br><span class="line">    userName: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一并的还有每个类型上的解析函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Query_User(request) &#123;</span><br><span class="line">    return request.auth.user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User_name &#123;</span><br><span class="line">    return user.getUserName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当服务运行后，其就可以接收graphql语句，并进行验证及执行。接收到的查询首先会被检查确保及只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> graphql </tag>
            
            <tag> 任务编排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphql</title>
      <link href="2021/12/20/develop/graphql/Schema%E5%92%8C%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/12/20/develop/graphql/Schema%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>简单而言，graphql是请求对象的指定字段，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  user &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>$\Downarrow$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;wang&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>从这可以看出查询和及结果基本是一样的结构，服务端根据查询即可准确的知道客户端请求的字段。<br>在例子中name返回了一个字符串，不过字段也可以是对象类型，也可以对这个对象进行次级选择，graph可以遍历相关对象及其字段，使得客户端可以一次性请求查询大量相关数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    user &#123;</span><br><span class="line">        name</span><br><span class="line">        roles &#123;</span><br><span class="line">            roleId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$\Downarrow$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;li&quot;,</span><br><span class="line">            &quot;roles&quot;:[</span><br><span class="line">                1, 2, 4</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 参数</span><br><span class="line"></span><br><span class="line">仅仅只是遍历对象不满足大部分的场景，不过graphql也支持参数传递</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;dotnetcli</span><br><span class="line">&#123;</span><br><span class="line">  human(id: &quot;1000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>$\Downarrow$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 1.72</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 —— 这可以让你重命名结果中的字段为任意你想到的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  empireHero: hero(episode: EMPIRE) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  jediHero: hero(episode: JEDI) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\Downarrow$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;empireHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;jediHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h1><p>假设我们的 app 有比较复杂的页面，将正反派主角及其友军分为两拨。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次 —— 两方各一次以作比较。</p><p>这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的地方引入。下面例子展示了如何使用片段解决上述场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">  friends &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\Downarrow$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作名称"><a href="#操作名称" class="headerlink" title="操作名称"></a>操作名称</h1><p>在这之前都是使用简写，省略了<code>Query</code>关键字和查询名称，正常完整写法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>操作类型可以是<code>query</code>、 <code>mutation</code>和<code>subscription</code>。采用简写方式下默认使用query</p><p>操作名称是操作的意义和明确的名称。它仅在多个操作文档中是必须的，但是这块对于调试及服务端日志追踪非常有用。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1>]]></content>
      
      
      
        <tags>
            
            <tag> graphql </tag>
            
            <tag> 任务编排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graphql</title>
      <link href="2021/12/20/develop/graphql/%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%8F%98%E6%9B%B4/"/>
      <url>2021/12/20/develop/graphql/%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%8F%98%E6%9B%B4/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>简单而言，graphql是请求对象的指定字段，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  user &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>返回的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;wang&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>从这可以看出查询和及结果基本是一样的结构，服务端根据查询即可准确的知道客户端请求的字段。</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1>]]></content>
      
      
      
        <tags>
            
            <tag> graphql </tag>
            
            <tag> 任务编排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oauth2.0</title>
      <link href="2021/10/12/develop/oauth/"/>
      <url>2021/10/12/develop/oauth/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/08/06/develop/review/"/>
      <url>2021/08/06/develop/review/</url>
      
        <content type="html"><![CDATA[<ol><li>服务迁移及基础架构建设</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RDD</title>
      <link href="2020/10/15/develop/RDD/"/>
      <url>2020/10/15/develop/RDD/</url>
      
        <content type="html"><![CDATA[<p>Responsibility driven design，软件本质上是复杂的，软件本身复杂性在于除了要解决问题域，还要解决非功能性需求和软件特有域的问题：安全性、可用性、可维护性、可扩展性、性能、一致性、容错性、可重用性、幂等、兼容等。<br>如何组织复杂的系统，把复杂的事物分解到不同层次中，层次代表了不同级别的抽象，一层构建于另一层之上，每一层都对上层屏蔽内部复杂度，每一层都需要有清晰的职责防止边界被破坏，边界的划分是重点也是难点。</p><span id="more"></span><h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p>职责驱动设计的核心是考虑怎样给对象分配职责，其适用于任何规模的软件。职责分配的本质是分工，劳动分工是劳动生产率提高的主要原因“</p><ul><li>熟练度提高，专注于某个领域（降低复杂度）</li><li>节约时间，同一个人在不同工作来回切换需要时间</li><li>人工发明的机器和应用（特定领域的工具）</li></ul><blockquote><p>分配职责应从清晰的职责描述开始，对于特定领域对象来说，领域模型描述了领域对象的属性和关联，对应类的属性和引用，用例模型包含一系列的行为活动，对应类的方法</p></blockquote><p>使用Grasp(General Resposibility Assignment Software Pattern)分配职责，是对一些基本职责分配进行命名及描述，共9中模式。</p><p><strong>低耦合，高内聚</strong>，问题不在于耦合度高、内聚低，而是在于其产生的负面影响，负面影响往往是发生变化时体现出来的，这些负面影响会影响到我们开发效率、稳定性、可维护性、可复用性等，Grasp核心就是防止变化。</p><h1 id="防止变异"><a href="#防止变异" class="headerlink" title="防止变异"></a>防止变异</h1><p>该模式基本等同于信息隐藏和开闭原则</p><p>识别预计变化或不稳定因素，分配职责用以在这些变化之外创建稳定接口</p><h1 id="低耦合、高内聚"><a href="#低耦合、高内聚" class="headerlink" title="低耦合、高内聚"></a>低耦合、高内聚</h1><p>耦合时对某元素与其他元素之间的连接、感知及依赖程度的度量，内聚是对元素职责的相关性和集中度的度量(元素可以指类，系统等)，耦合内聚是从不同角度看待问题</p><ul><li>内聚过低：相关功能分散不同的模块，需要增加额外的耦合使得这些功能聚合在一起，发生变更时影响多个模块</li><li>内聚过高： 不相关功能聚集在同一个模块中，耦合度高，发生变更时容易影响其他功能。</li></ul><h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>耦合高主要是解决不良依赖，不良依赖导致的影响有：</p><ul><li>依赖关系本身错综复杂难以理解，很容易产生遗漏和问题</li><li>与不稳定元素产生依赖时容易受到变化的影响</li></ul><p>依赖好坏的评估有如下几点：</p><ul><li>依赖方向： 双向依赖与循环依赖很差，最好保持单向依赖</li><li>依赖链路： 取决于依赖的深度及广度</li><li>依赖方式： 以相对独立的方式（数据）进行耦合，直接耦合或者内容耦合等方式会增加复杂度</li></ul><h2 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h2><p>将关联性强或类似的模块内聚到同一个</p><h1 id="创建者"><a href="#创建者" class="headerlink" title="创建者"></a>创建者</h1><p>创建者指导分配那些与对象相关的职责，保持低耦合</p><p>满足以下条件时，将创建类A的职责分配给B</p><ul><li>B 包含 A</li><li>B 记录 A</li><li>B 频繁使用 A</li><li>B 具有 A 的初始化数据，该数据在初始化时传给 A </li></ul><p>该种方式支持低耦合，因为创建者和被创建者已经存在关联，所以这种方式不会增加耦合性</p><h1 id="信息专家"><a href="#信息专家" class="headerlink" title="信息专家"></a>信息专家</h1><p>对象使用自身信息来完成任务，所以封装性好，也保持了低耦合。行为分布在那些需要信息的类之间，功能更加集中。比如由订单自身计算金额</p><h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><p>控制器核心是提供一个统一入口，避免对元素内部进行耦合，很好维护了边界</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>当相关选择或者行为随类型有所不同时，可使用多态</p><h1 id="间接性"><a href="#间接性" class="headerlink" title="间接性"></a>间接性</h1><p>将职责分配给中介对象，使其作为其他构建或服务之间的媒介，以避免他们之间的直接耦合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>groovy在业务场景的使用</title>
      <link href="2020/10/15/develop/groovy/"/>
      <url>2020/10/15/develop/groovy/</url>
      
        <content type="html"><![CDATA[<p>在服务商的业务中，由于服务商入驻环节统一放在<a href="https://jigou.kuaishou.com/workbench">机构平台</a>，而一个正常的入驻的步骤及中间状态都比较多，导致在开发过程中测试数据不方便构造，可能也会遗漏一些边界场景。</p><p>对于这个问题，之前的解决方式是</p><ol><li>联系机构平台同学帮忙构造数据，这种方式效率比较低，而且不利于写集成测试</li><li>代码中加开关内容在kconf中配置或者直接将测试数据写在代码中；这种方式污染代码而且不是很通用</li></ol><p>基于这些痛点，groovy的用处就体现出来了，作为用于JVM的动态语言，与java结合性非常好，可以很好的解决上面这些问题。</p><h1 id="在项目内的实践"><a href="#在项目内的实践" class="headerlink" title="在项目内的实践"></a>在项目内的实践</h1><h1 id="使用场景的扩展"><a href="#使用场景的扩展" class="headerlink" title="使用场景的扩展"></a>使用场景的扩展</h1><p>我们可以先定义个注解比如<code>Script</code>作为切入点，标注在需要mock的方法上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Script(&quot;mock.groovy&quot;)</span><br><span class="line"> public CpOrgSettledDetailInfo getOrgInfo(@MockKey int businessType, @MockKey long orgId) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用rpc获取数据</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>指定要执行的脚本后我们就可以编写具体的实现逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private final GroovyShell groovyShell &#x3D; new GroovyShell();</span><br><span class="line"></span><br><span class="line"> @Around(&quot;@annotation(com.kuaishou.kwaishop.spplatform.admin.annotation.Script)&quot;)</span><br><span class="line">    public Object mockResponse(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        boolean enable &#x3D; BooleanConfigKey.mockResponseEnable.get() &amp;&amp; EnvUtils.belowStaging();</span><br><span class="line">        if (!enable) &#123;</span><br><span class="line">            return joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            MethodSignature methodSignature &#x3D; (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            Script script &#x3D; methodSignature.getMethod().getAnnotation(Script.class);</span><br><span class="line">            Object result &#x3D; invokeScript(script, methodSignature.getName(), joinPoint.getArgs());</span><br><span class="line">            return result &#x3D;&#x3D; null ? joinPoint.proceed() : result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;mock failed,args:&#123;&#125;&quot;, joinPoint.getArgs(), e);</span><br><span class="line">            return joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> private Object invokeScript(Script script, String method, Object[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String scriptContent &#x3D; getScript(script);</span><br><span class="line">            if (StringUtils.isEmpty(scriptContent)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return groovyShell.parse(scriptContent).invokeMethod(method, args);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.warn(&quot;invoke script failed, method:&#123;&#125;&quot;, method, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            groovyShell.resetLoadedClasses();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br> 脚本路径可以自定义，结合kconf效果更好。</p><p>接下来只需要在编写脚本语言即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import com.google.protobuf.util.JsonFormat</span><br><span class="line">import com.kuaishou.protobuf.operation.cp.org.settled.CpOrgSettledDetailInfo</span><br><span class="line">import groovy.transform.Field</span><br><span class="line">import org.apache.commons.lang3.StringUtils</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这里就可以由测试或者开发自己修改相应的边界值</span><br><span class="line">*&#x2F;</span><br><span class="line">@Field</span><br><span class="line">def table &#x3D; [&quot;7&quot;: [&quot;9179&quot;: &quot;具体json&quot;]]</span><br><span class="line"></span><br><span class="line">CpOrgSettledDetailInfo getOrgInfo(int businessType, long orgId) &#123;</span><br><span class="line">    return parse(table?.getAt(businessType.toString())?.getAt(orgId.toString()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private CpOrgSettledDetailInfo parse(String json) &#123;</span><br><span class="line">    if (StringUtils.isEmpty(json)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    def builder &#x3D; CpOrgSettledDetailInfo.newBuilder()</span><br><span class="line">    JsonFormat.parser().merge(json, builder)</span><br><span class="line">    return builder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>单个功能的各种case都没问题后，直接删除脚本中对应的方法即可，不用修改java代码，保证了仓库中代码的整洁性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm即时编译</title>
      <link href="2020/10/15/develop/jvm%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/"/>
      <url>2020/10/15/develop/jvm%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>常见的编译型语言如C，C++，这种类型的语言会直接把代码编译成CPU所能理解的机器码。而java为了实现<em>一次编译，到处运行</em>的特性，把编译过程分成两部分：先将代码编译成字节码，然后再由解释器将字节码翻译成机器码。所以性能上对比编译型语言有所欠缺。</p><span id="more"></span><p>为了优化java性能，jvm在解释器之外引入了即时编译器（Just In Time)：当程序运行时，解释器先发挥作用，代码可以直接运行。随者时间推移，即时编译器逐渐发挥作用，把越来越多的代码翻译成本地代码，来获取更高的执行效率。这时的解释器可以作为降级手段，在一些不可靠的编译优化出现问题时，将切回解释执行，保证程序正常运行。</p><p>即时编译器极大提高了Java程序的运行速度，而且与静态编译相比，即时编译器可以选择性的编译热点代码，省去很多编译时间，也节省很多空间，目前即时编译器已经非常成熟，在性能上可以与编译型语言相比。</p><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>java执行过程整体可以分成两个部分，第一步由javac将源码编译成字节码，在这个过程中会进行词法分析，语法分析，语义分析，编译原理中这部分称之为前端编译。接下来无需编译，直接逐条将字节码解释执行，在解释过程中，虚拟机同时对运行信息进行收集，在这些信息的基础上，编译器会逐渐发挥作用，它会对后端编译-将字节码翻译成机器码，但不是所有代码都会被编译，只有jvm认定为热点代码，才可能被编译。</p><p>怎么样才被认定为热点代码？jvm中会设置一个阈值，当方法或者代码块在一定时间内超过这个阈值，就会被编译，存入code cache，当下次执行时，再次遇到这段代码，就会从code cache中读取机器码，直接执行，以此提升程序运行性能，如图所示<br><img src="/images/jit1.png" alt=""></p><h2 id="jvm编译器"><a href="#jvm编译器" class="headerlink" title="jvm编译器"></a>jvm编译器</h2><p>jvm中集成了两种编译器，Client Compiler和Server Compiler，他们的作用也不。Client Compiler注重于启动速度和局部优化，一般用于客户端，Server Compiler则更关注全局的优化，性能更好，但由于会进行更多的全局分析，所以启动速度会变慢。</p><h3 id="Client-Compiler"><a href="#Client-Compiler" class="headerlink" title="Client Compiler"></a>Client Compiler</h3><p>HotSpot VM带有一个Client Compiler，C1编译器。这种编译器启动速度非常快，但是性能比较Server Compiler来说会差一些。C1会做三件事：</p><ul><li>局部简单可靠的优化，比如字节码上进行一些基础优化，方法内联，常量传播等，放弃许多耗时较长的全局优化</li><li>将字节码构造成高级中间表示（High-level Intermediate Representation) ,HIR与平台无关，通常采用图结构，更适合JVM对程序进行优化</li><li>最后将HIR转换成低级中间表示（Low-level Intermediate Representation），在LIR的基础上会进行寄存器分配，窥孔优化（局部的优化方式，编译器在一个基本块或者多个基础块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则或者通过整体分析，进行指令转换，来提升代码性能），最终生成机器码</li></ul><h3 id="Server-Compiler"><a href="#Server-Compiler" class="headerlink" title="Server Compiler"></a>Server Compiler</h3><p>Server Compiler主要关注一些编译耗时较长的全局优化，甚至会根据程序运行信息进行一些不可靠的激进优化。这种编译器启动时间长，适用于长时间运行的后台程序，它的性能通常比Client Compiler高<code>30%</code>以上。目前Hot Spot虚拟机使用的Server Compiler有两种，C2和Graal</p><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2编译器在进行编译优化时，会使用一种控制流和数据流结合的图数据结构，称为Ideal Graph，表示当前程序的数据流向和指令间的依赖关系，依靠这种图结构，某些优化步骤（尤其涉及浮动代码块的优化）变得不那么复杂。</p><p>Ideal Graph的构建是在解析字节码的时候，根据字节码中的指令向一个空的Graph中添加节点，Graph中的节点通常对应一个指令块，每个指令块包含多条相关联的指令，JVM会利用一些优化技术对这些指令优化，比如Global Value Numbering，常量折叠等，解析结束后还会进行一些死代码剔除的操作。生成Ideal Graph后，会在这个基础上结合收集的程序运行信息来进行一些全局优化，这个阶段如果JVM判定没有全局优化的必要，则会跳过这个步骤。</p><p>无论是否进行全局优化，Ideal Graph都会被转化为一种更接近机器层面的MachNode Graph,最后编译的机器码就是从MachNode Graph中得到，生成的机器码前还会有一些包括寄存器分配，窥孔优化等操作。<br><img src="/images/jit2.png" alt=""></p><h4 id="Graal-Compiler"><a href="#Graal-Compiler" class="headerlink" title="Graal Compiler"></a>Graal Compiler</h4><p>从JDK9开始，HotSpot虚拟机集成了一种新的Server Compiler：Graal编译器。相比C2，Graal有这几种关键特性</p><ul><li>Graal会更侧重于分支预测等激进优化</li><li>使用Java编写，对于新特性如Lambda,Stream支持更友好</li><li>更深层次的优化，如虚函数内联，部分逃逸分析等</li></ul><p>当前还处于实验状态，启用方式： <code>-XX:+UnlockExperimentalVMOptions -X:+UseJVMCICompiler</code></p><h1 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h1><p>在java7之前，需要研发人员根据服务性质去选择编译器，对于需要快速启动的或者不太长时间运行的服务，可以选择C1，长时间运行的服务或者对于峰值有要求的后台服务，可以采用峰值性能更好的C2.java7开始引入了分层编译概念，结合了C1和C2优势，追求启动速度和峰值性能的一个平衡。编译器将JVM执行分成了五个层级：</p><ol start="0"><li>解释执行</li><li>执行不带Profiling的C1代码</li><li>执行仅带方法调用次数以及循环回边次数Profiling的C1代码</li><li>执行带所有Profiling的C1代码</li><li>执行C2代码</li></ol><p>Profiling就是能够收集反应程序执行状态的数据。其中基础的统计数据就是方法的调用次数以及循环回边的执行次数。</p><p>通常情况下，C2代码的执行效率要比C1代码高出30以上，C1层执行的代码，按执行效率排序高至低则是<code>1&gt;2&gt;3</code>，在五层中1，4都是处于终止状态，当一个方法达到终止状态后，只要编译后的代码没有失效，那么JVM就不会再次发出该方法的编译请求。服务实际运行时。JVM会根据服务运行情况，从解释执行开始，选择不同的编译路径，直到到达终止状态。<br><img src="/images/jit3.png" alt=""></p><ul><li>图中第一条路径，代码一般编译情况，热点方法从解释执行到3层的C1编译，最后被第四层编译</li><li>如果方法比较小(getter/setter)，三层的profiling没有收集到有价值的数据，JVM就会断定该方法对于C1,C2的执行效率相同，就会执行途中2这条路径，在这种情况下，JVM在三层编译后会放弃C2编译</li><li>在C1忙碌的情况下，执行途中3路径，在解释过程中对程序Profiling，根据信息直接选择C2编译</li><li>在C2忙碌的情况下会先选择二层的编译，再选择三层的编译，以减少三层的执行时间</li><li>如果编译器做了一些比较激进的优化，比如分支预测，在实际运行中发现预测错误，这时会进行反优化，重新进入解释执行</li></ul><p>总的来说C1编译速度快，C2编译质量高，分层编译的不同编译路径，也就是根据程序运行情况来寻找当前服务的最佳平衡点，从JDK8开始，JVM默认分层编译</p><h2 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h2><p>JVM根据方法调用次数以及循环回边执行次数来触发即时编译。循环回边时一个控制流中的概念，在程序中可以简单理解成往回跳转的代码，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(Object obj) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; 200; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该代码经过编译生成如下字节码。其中偏移量为18的字节码将往回跳至偏移量为4的字节码中，在解释执行时，没运行一次该指令，JVM会将该方法的循环回边加1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void nlp(java.lang.Object);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_0</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: sipush        200</span><br><span class="line">       8: if_icmpge     21</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: iload_2</span><br><span class="line">      13: iadd</span><br><span class="line">      14: istore_1</span><br><span class="line">      15: iinc          2, 1</span><br><span class="line">      18: goto          4</span><br><span class="line">      21: return</span><br></pre></td></tr></table></figure><br>在即时编译过程中，编译器会识别循环的头部和尾部。上面这段字节码中，循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码。编译器将在循环体结尾增加循环回边计数器的代码，来对循环进行计数。当方法的调用次数和循环回边的次数的和，超过由参数<code>-XX:CompileThreshold</code>指定的阈值时（使用C1时，默认值为1500；使用C2时，默认值为10000），就会触发即时编译。</p><p>开启分层编译的情况下，-XX:CompileThreshold参数设置的阈值将会失效，触发编译会由以下的条件来判断：<br>方法调用次数大于由参数-XX:TierXInvocationThreshold指定的阈值乘以系数。</p><p>方法调用次数大于由参数-XX:TierXMINInvocationThreshold指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数-XX:TierXCompileThreshold指定的阈值乘以系数时。</p><h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><p>即时编译器会对正在运行的服务进行一系列的优化，包括字节码解析过程中的分析，根据编译过程中代码的一些中间形式来做局部优化，还会根据程序依赖图进行全局优化，最后才会生成机器码。</p><h2 id="中间表达形式"><a href="#中间表达形式" class="headerlink" title="中间表达形式"></a>中间表达形式</h2><p>在编译原理中，通常把编译器分为前端和后端，前端编译经过词法分析、语法分析、语义分析生成中间表达形式（Intermediate Representation，以下称为IR），后端会对IR进行优化，生成目标代码。</p><p>Java字节码就是一种IR，但是字节码的结构复杂，字节码这样代码形式的IR也不适合做全局的分析优化。现代编译器一般采用图结构的IR，静态单赋值（Static Single Assignment，SSA）IR是目前比较常用的一种。这种IR的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a &#x3D; 1;</span><br><span class="line">  a &#x3D; 2;</span><br><span class="line">  b &#x3D; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以轻易地发现a = 1的赋值是冗余的，但是编译器不能。传统的编译器需要借助数据流分析，从后至前依次确认哪些变量的值被覆盖掉。不过，如果借助了SSA IR，编译器则可以很容易识别冗余赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plain Text</span><br><span class="line">&#123;</span><br><span class="line">  a_1 &#x3D; 1;</span><br><span class="line">  a_2 &#x3D; 2;</span><br><span class="line">  b_1 &#x3D; a_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于SSA IR中每个变量只能赋值一次，所以代码中的a在SSA IR中会分成a_1、a_2两个变量来赋值，这样编译器就可以很容易通过扫描这些变量来发现a_1的赋值后并没有使用，赋值是冗余的。</p><p>除此之外，SSA IR对其他优化方式也有很大的帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a &#x3D; 2;</span><br><span class="line">  int b &#x3D; 0</span><br><span class="line">  if(2 &gt; 1)&#123;</span><br><span class="line">    a &#x3D; 1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    b &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到SSA IR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_1 &#x3D; 2;</span><br><span class="line">b_1 &#x3D; 0</span><br><span class="line">if true:</span><br><span class="line">  a_2 &#x3D; 1;</span><br><span class="line">else</span><br><span class="line">  b_2 &#x3D; 2;</span><br><span class="line">add(a,b)</span><br></pre></td></tr></table></figure><br>编译器通过执行字节码可以发现 b_2 赋值后不会被使用，else分支不会被执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void DeadCodeElimination&#123;</span><br><span class="line">  int a &#x3D; 1;</span><br><span class="line">  int b &#x3D; 0;</span><br><span class="line">  add(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以将编译器的每一种优化看成一个图优化算法，它接收一个IR图，并输出经过转换后的IR图。编译器优化的过程就是一个个图节点的优化串联起来的</p><h2 id="C1中的中间表达形式"><a href="#C1中的中间表达形式" class="headerlink" title="C1中的中间表达形式"></a>C1中的中间表达形式</h2><p>HIR是由很多基本块（Basic Block）组成的控制流图结构，每个块包含很多SSA形式的指令。基本块的结构如下图所示：<br><img src="/images/jit4.png" alt=""></p><p>其中，predecessors表示前驱基本块（由于前驱可能是多个，所以是BlockList结构，是多个BlockBegin组成的可扩容数组）。同样，successors表示多个后继基本块BlockEnd。除了这两部分就是主体块，里面包含程序执行的指令和一个next指针，指向下一个执行的主体块。</p><p>从字节码到HIR的构造最终调用的是GraphBuilder，GraphBuilder会遍历字节码构造所有代码基本块储存为一个链表结构，但是这个时候的基本块只有BlockBegin，不包括具体的指令。第二步GraphBuilder会用一个ValueStack作为操作数栈和局部变量表，模拟执行字节码，构造出对应的HIR，填充之前空的基本块，这里给出简单字节码块构造HIR的过程示例，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字节码                     Local Value             operand stack              HIR</span><br><span class="line"> 5: iload_1                  [i1,i2]                 [i1]</span><br><span class="line"> 6: iload_2                  [i1,i2]                 [i1,i2]   </span><br><span class="line">                             ................................................   i3: i1 * i2</span><br><span class="line"> 7: imul                                   </span><br><span class="line"> 8: istore_3                 [i1,i2，i3]              [i3]</span><br></pre></td></tr></table></figure><br>可以看出，当执行iload_1时，操作数栈压入变量i1，执行iload_2时，操作数栈压入变量i2，执行相乘指令imul时弹出栈顶两个值，构造出HIR i3 : i1 * i2，生成的i3入栈。<br>C1编译器优化大部分都是在HIR之上完成的。当优化完成之后它会将HIR转化为LIR，LIR和HIR类似，也是一种编译器内部用到的IR，HIR通过优化消除一些中间节点就可以生成LIR，形式上更加简化。</p><h3 id="Sea-of-Nodes-IR"><a href="#Sea-of-Nodes-IR" class="headerlink" title="Sea-of-Nodes IR"></a>Sea-of-Nodes IR</h3><p>C2编译器中的Ideal Graph采用的是一种名为Sea-of-Nodes中间表达形式，同样也是SSA形式的。它最大特点是去除了变量的概念，直接采用值来进行运算。为了方便理解，可以利用IR可视化工具Ideal Graph Visualizer（IGV），来展示具体的IR图。比如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int foo(int count) &#123;</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">    sum +&#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对应IR如下<br><img src="/images/jit5.png" alt=""></p><p>图中若干个顺序执行的节点将被包含在同一个基本块之中，如图中的B0、B1等。B0基本块中0号Start节点是方法入口，B3中21号Return节点是方法出口。红色加粗线条为控制流，蓝色线条为数据流，而其他颜色的线条则是特殊的控制流或数据流。被控制流边所连接的是固定节点，其他的则是浮动节点（浮动节点指只要能满足数据依赖关系，可以放在不同位置的节点，浮动节点变动的这个过程称为Schedule）。</p><p>这种图具有轻量级的边结构。图中的边仅由指向另一个节点的指针表示。节点是Node子类的实例，带有指定输入边的指针数组。这种表示的优点是改变节点的输入边很快，如果想要改变输入边，只要将指针指向Node，然后存入Node的指针数组就可以了。</p><p>依赖于这种图结构，通过收集程序运行的信息，JVM可以通过Schedule那些浮动节点，从而获得最好的编译效果。</p><h3 id="Phi-And-Region-Nodes"><a href="#Phi-And-Region-Nodes" class="headerlink" title="Phi And Region Nodes"></a>Phi And Region Nodes</h3><p>Ideal Graph是SSA IR。由于没有变量的概念，这会带来一个问题，就是不同执行路径可能会对同一变量设置不同的值。例如下面这段代码if语句的两个分支中，分别返回5和6。此时，根据不同的执行路径，所读取到的值很有可能不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">  if(x &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    a &#x3D; 5;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a &#x3D; 6;</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了解决这个问题，就引入一个Phi Nodes的概念，能够根据不同的执行路径选择不同的值。于是，上面这段代码可以表示为下面这张图：<br><img src="/images/jit6.png" alt=""></p><p>Phi Nodes中保存不同路径上包含的所有值，Region Nodes根据不同路径的判断条件，从Phi Nodes取得当前执行路径中变量应该赋予的值，带有Phi节点的SSA形式的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int test(int x) &#123;</span><br><span class="line">  a_1 &#x3D; 0;</span><br><span class="line">  if(x &#x3D;&#x3D; 1)&#123;</span><br><span class="line">    a_2 &#x3D; 5;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    a_3 &#x3D; 6;</span><br><span class="line">  &#125;</span><br><span class="line">  a_4 &#x3D; Phi(a_2,a_3);</span><br><span class="line">  return a_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Global-Value-Numbering"><a href="#Global-Value-Numbering" class="headerlink" title="Global Value Numbering"></a>Global Value Numbering</h3><p>Global Value Numbering（GVN） 是一种因为Sea-of-Nodes变得非常容易的优化技术 。</p><p>GVN是指为每一个计算得到的值分配一个独一无二的编号，然后遍历指令寻找优化的机会，它可以发现并消除等价计算的优化技术。如果一段程序中出现了多次操作数相同的乘法，那么即时编译器可以将这些乘法合并为一个，从而降低输出机器码的大小。如果这些乘法出现在同一执行路径上，那么GVN还将省下冗余的乘法操作。在Sea-of-Nodes中，由于只存在值的概念，因此GVN算法将非常简单：即时编译器只需判断该浮动节点是否与已存在的浮动节点的编号相同，所输入的IR节点是否一致，便可以将这两个浮动节点归并成一个。比如下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1;</span><br><span class="line">b &#x3D; 2;</span><br><span class="line">c &#x3D; a + b;</span><br><span class="line">d &#x3D; a + b;</span><br><span class="line">e &#x3D; d;</span><br></pre></td></tr></table></figure><br>GVN会利用Hash算法编号，计算a = 1时，得到编号1，计算b = 2时得到编号2，计算c = a + b时得到编号3，这些编号都会放入Hash表中保存，在计算d = a + b时，会发现a + b已经存在Hash表中，就不会再进行计算，直接从Hash表中取出计算过的值。最后的e = d也可以由Hash表中查到而进行复用。</p><p>可以将GVN理解为在IR图上的公共子表达式消除（Common Subexpression Elimination，CSE）。两者区别在于，GVN直接比较值的相同与否，而CSE是借助词法分析器来判断两个表达式相同与否。</p><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联，是指在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。JIT大部分的优化都是在内联的基础上进行的，方法内联是即时编译器中非常重要的一环。</p><p>Java服务中存在大量getter/setter方法，如果没有方法内联，在调用getter/setter时，程序执行时需要保存当前方法的执行位置，创建并压入用于getter/setter的栈帧、访问字段、弹出栈帧，最后再恢复当前方法的执行。内联了对 getter/setter的方法调用后，上述操作仅剩字段访问。在C2编译器 中，方法内联在解析字节码的过程中完成。当遇到方法调用字节码时，编译器将根据一些阈值参数决定是否需要内联当前方法的调用。如果需要内联，则开始解析目标方法的字节码。比如下面这个示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static boolean flag &#x3D; true;</span><br><span class="line">public static int value0 &#x3D; 0;</span><br><span class="line">public static int value1 &#x3D; 1;</span><br><span class="line"></span><br><span class="line">public static int foo(int value) &#123;</span><br><span class="line">    int result &#x3D; bar(flag);</span><br><span class="line">    if (result !&#x3D; 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int bar(boolean flag) &#123;</span><br><span class="line">    return flag ? value0 : value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jit7.png" alt=""><br>内联后的IR图：<br><img src="/images/jit8.png" alt=""></p><p>内联不仅将被调用方法的IR图节点复制到调用者方法的IR图中，还要完成其他操作。</p><ul><li>被调用方法的参数替换为调用者方法进行方法调用时所传入参数。上面例子中，将bar方法中的1号P(0)节点替换为foo方法3号LoadField节点。</li><li>调用者方法的IR图中，方法调用节点的数据依赖会变成被调用方法的返回。如果存在多个返回节点，会生成一个Phi节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。图中就是将8号==节点，以及12号Return节点连接到原5号Invoke节点的边，然后指向新生成的24号Phi节点中。</li><li>如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接。</li></ul><h4 id="方法内联的条件"><a href="#方法内联的条件" class="headerlink" title="方法内联的条件"></a>方法内联的条件</h4><p>编译器的大部分优化都是在方法内联的基础上。所以一般来说，内联的方法越多，生成代码的执行效率越高。但是对于即时编译器来说，内联的方法越多，编译时间也就越长，程序达到峰值性能的时刻也就比较晚。</p><p>可以通过虚拟机参数-XX:MaxInlineLevel调整内联的层数，以及1层的直接递归调用（可以通过虚拟机参数-XX:MaxRecursiveInlineLevel调整）。一些常见的内联相关的参数如下表所示：<br><img src="/images/jit9.png" alt=""></p><h4 id="虚函数内联"><a href="#虚函数内联" class="headerlink" title="虚函数内联"></a>虚函数内联</h4><p>内联是JIT提升性能的主要手段，但是虚函数使得内联是很难的，因为在内联阶段并不知道他们会调用哪个方法。例如，我们有一个数据处理的接口，这个接口中的一个方法有三种实现add、sub和multi，JVM是通过保存虚函数表Virtual Method Table（以下称为VMT）存储class对象中所有的虚函数，class的实例对象保存着一个VMT的指针，程序运行时首先加载实例对象，然后通过实例对象找到VMT，通过VMT找到对应方法的地址，所以虚函数的调用比直接指向方法地址的classic call性能上会差一些。很不幸的是，Java中所有非私有的成员函数的调用都是虚调用。</p><p>C2编译器已经足够智能，能够检测这种情况并会对虚调用进行优化。比如下面这段代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleInliningTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        VirtualInvokeTest obj &#x3D; new VirtualInvokeTest();</span><br><span class="line">        VirtualInvoke1 obj1 &#x3D; new VirtualInvoke1();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            invokeMethod(obj);</span><br><span class="line">            invokeMethod(obj1);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void invokeMethod(VirtualInvokeTest obj) &#123;</span><br><span class="line">        obj.methodCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvokeTest &#123;</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            System.out.println(&quot;virtual call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class VirtualInvoke1 extends VirtualInvokeTest &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void methodCall() &#123;</span><br><span class="line">            super.methodCall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过JIT编译器优化后，进行反汇编得到下面这段汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000113369d37: callq  0x00000001132950a0  ; OopMap&#123;off&#x3D;476&#125;</span><br><span class="line">                                               ;*invokevirtual methodCall  &#x2F;&#x2F;代表虚调用</span><br><span class="line">                                               ; - SimpleInliningTest::invokeMethod@1 (line 18)</span><br><span class="line">                                               ;   &#123;optimized virtual_call&#125;  &#x2F;&#x2F;虚调用已经被优化</span><br></pre></td></tr></table></figure><br>可以看到JIT对methodCall方法进行了虚调用优化optimized virtual_call。经过优化后的方法可以被内联。但是C2编译器的能力有限，对于多个实现方法的虚调用就“无能为力”了。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”。Java虚拟机的即时编译器会对新建的对象进行逃逸分析，判断对象是否逃逸出线程或者方法。即时编译器判断对象是否逃逸的依据有两种：<br>对象是否被存入堆中（静态字段或者堆中对象的实例字段），一旦对象被存入堆中，其他线程便能获得该对象的引用，即时编译器就无法追踪所有使用该对象的代码位置。<br>对象是否被传入未知代码中，即时编译器会将未被内联的代码当成未知代码，因为它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中，这种情况，可以直接认为方法调用的调用者以及参数是逃逸的。</p><p>逃逸分析通常是在方法内联的基础上进行的，即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。下面这段代码的就是对象未逃逸的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pulbic class Example&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      example();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void example() &#123;</span><br><span class="line">      Foo foo &#x3D; new Foo();</span><br><span class="line">      Bar bar &#x3D; new Bar();</span><br><span class="line">      bar.setFoo(foo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Foo &#123;&#125;</span><br><span class="line"></span><br><span class="line">  class Bar &#123;</span><br><span class="line">    private Foo foo;</span><br><span class="line">    public void setFoo(Foo foo) &#123;</span><br><span class="line">      this.foo &#x3D; foo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，创建了两个对象foo和bar，其中一个作为另一个方法的参数提供。该方法setFoo()存储对收到的Foo对象的引用。如果Bar对象在堆上，则对Foo的引用将逃逸。但是在这种情况下，编译器可以通过逃逸分析确定Bar对象本身不会对逃逸出example()的调用。这意味着对Foo的引用也不能逃逸。因此，编译器可以安全地在栈上分配两个对象。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>在学习Java并发编程时会了解锁消除，而锁消除就是在逃逸分析的基础上进行的。</p><p>如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没就有意义。因为线程并不能获得该锁对象。在这种情况下，即时编译器会消除对该不逃逸锁对象的加锁、解锁操作。实际上，编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。不过，基于逃逸分析的锁消除实际上并不多见。</p><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>我们都知道Java的对象是在堆上分配的，而堆是对所有对象可见的。同时，JVM需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。如果逃逸分析能够证明某些新建的对象不逃逸，那么JVM完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。</p><p>这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。不过Hotspot虚拟机，并没有进行实际的栈上分配，而是使用了标量替换这一技术。所谓的标量，就是仅能存储一个值的变量，比如Java代码中的基本类型。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java的对象。编译器会在方法内将未逃逸的聚合量分解成多个标量，以此来减少堆上分配。下面是一个标量替换的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    Cat cat &#x3D; new Cat(1,10);</span><br><span class="line">    addAgeAndWeight(cat.age,Cat.weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过逃逸分析，cat对象未逃逸出example()的调用，因此可以对聚合量cat进行分解，得到两个标量age和weight，进行标量替换后的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">  @AllArgsConstructor</span><br><span class="line">  class Cat&#123;</span><br><span class="line">    int age;</span><br><span class="line">    int weight;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void example()&#123;</span><br><span class="line">    int age &#x3D; 1;</span><br><span class="line">    int weight &#x3D; 10;</span><br><span class="line">    addAgeAndWeight(age,weight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="部分逃逸分析"><a href="#部分逃逸分析" class="headerlink" title="部分逃逸分析"></a>部分逃逸分析</h4><p>部分逃逸分析也是Graal对于概率预测的应用。通常来说，如果发现一个对象逃逸出了方法或者线程，JVM就不会去进行优化，但是Graal编译器依然会去分析当前程序的执行路径，它会在逃逸分析基础上收集、判断哪些路径上对象会逃逸，哪些不会。然后根据这些信息，在不会逃逸的路径上进行锁消除、栈上分配这些优化手段。</p><h3 id="Loop-Transformations"><a href="#Loop-Transformations" class="headerlink" title="Loop Transformations"></a>Loop Transformations</h3><p>C2编译器在构建Ideal Graph后会进行很多的全局优化，其中就包括对循环的转换，最重要的两种转换就是循环展开和循环分离</p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开是一种循环转换技术，它试图以牺牲程序二进制码大小为代价来优化程序的执行速度，是一种用空间换时间的优化手段</p><p>循环展开通过减少或消除控制程序循环的指令，来减少计算开销，这种开销包括增加指向数组中下一个索引或者指令的指针算数等。如果编译器可以提前计算这些索引，并且构建到机器代码指令中，那么程序运行时就可以不必进行这种计算。也就是说有些循环可以写成一些重复独立的代码。比如下面这个循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i &#x3D; 0;i&lt;200;i++)&#123;</span><br><span class="line">    delete(i);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码需要循环删除200次，通过循环展开可以得到下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void loopRolling()&#123;</span><br><span class="line">  for(int i &#x3D; 0;i&lt;200;i+&#x3D;5)&#123;</span><br><span class="line">    delete(i);</span><br><span class="line">    delete(i+1);</span><br><span class="line">    delete(i+2);</span><br><span class="line">    delete(i+3);</span><br><span class="line">    delete(i+4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样展开就可以减少循环的次数，每次循环内的计算也可以利用CPU的流水线提升效率。当然这只是一个示例，实际进行展开时，JVM会去评估展开带来的收益，再决定是否进行展开。</p><h3 id="循环分离"><a href="#循环分离" class="headerlink" title="循环分离"></a>循环分离</h3><p>循环分离也是循环转换的一种手段。它把循环中一次或多次的特殊迭代分离出来，在循环外执行。举个例子，下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">for(int i &#x3D; 0;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] &#x3D; x[i] + x[a];</span><br><span class="line">  a &#x3D; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出这段代码除了第一次循环a = 10以外，其他的情况a都等于i-1。所以可以把特殊情况分离出去，变成下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[0] &#x3D; x[0] + 10;</span><br><span class="line">for(int i &#x3D; 1;i&lt;10;i++)&#123;</span><br><span class="line">  b[i] &#x3D; x[i] + x[i-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种等效的转换消除了在循环中对a变量的需求，从而减少了开销。</p><h3 id="窥孔优化与寄存器分配"><a href="#窥孔优化与寄存器分配" class="headerlink" title="窥孔优化与寄存器分配"></a>窥孔优化与寄存器分配</h3><p>窥孔优化是优化的最后一步，这之后就会程序就会转换成机器码，窥孔优化就是将编译器所生成的中间代码（或目标代码）中相邻指令，将其中的某些组合替换为效率更高的指令组，常见的比如强度削减、常数合并等，看下面这个例子就是一个强度削减的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1&#x3D;x1*3  经过强度削减后得到  y1&#x3D;(x1&lt;&lt;1)+x1</span><br></pre></td></tr></table></figure></p><p>编译器使用移位和加法削减乘法的强度，使用更高效率的指令组。</p><p>寄存器分配也是一种编译的优化手段，在C2编译器中普遍的使用。它是通过把频繁使用的变量保存在寄存器中，CPU访问寄存器的速度比内存快得多，可以提升程序的运行速度。</p><p>寄存器分配和窥孔优化是程序优化的最后一步。经过寄存器分配和窥孔优化之后，程序就会被转换成机器码保存在codeCache中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>innodb两次写</title>
      <link href="2020/10/15/develop/innodb/double%20write/"/>
      <url>2020/10/15/develop/innodb/double%20write/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="部分写失败问题"><a href="#部分写失败问题" class="headerlink" title="部分写失败问题"></a>部分写失败问题</h1><p>部分写失败主要是文件系统定义的页大小与磁盘(512)大小不一致导致。 innodb的page size一般是16kb，其数据校验也是根据这16kb来计算，将数据写入磁盘都是已Page为单位进行操作，在innodb刷脏页写磁盘的时候，需要进行多次的磁盘io，而这个步骤不是原子的，如果中间发生断电、服务器宕机等情况，就会导致只在磁盘写入部分数据。</p><p>我们也知道，innodb中redolog可以用来数据恢复，那这个情况是否可以恢复？这个情况下其实redolog是恢复不了的，redolog中记录的是对页的物理操作，比如<code>偏移xx，写入xxxx</code>。如果页本身已经损坏，再对其进行重做是没有意义的。mysql在恢复过程中会检查page的校验和，如果page损坏导致写之前就无法通过校验。如果强制写入，可能会导致一些逻辑错误。</p><p>因为这个原因，innodb实现了double write buffer；</p><h1 id="double-write"><a href="#double-write" class="headerlink" title="double write"></a>double write</h1><p>double write由两部分组成，一部分是innodb内存中的double write buffer，大小为2M，另一部分是物理磁盘上ibdata系统表空间中的2M，共128个连续的page，即两个分区。其中120个页用于批量刷新脏页，另外8个页用于单页刷新</p><p><img src="/images/innodb/double_write.jpeg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROR入门踩坑</title>
      <link href="2020/04/21/develop/ruby-on-rails/"/>
      <url>2020/04/21/develop/ruby-on-rails/</url>
      
        <content type="html"><![CDATA[<p>rails使用ruby写的一个web应用开发框架</p><h1 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h1><h2 id="检查ruby是否安装"><a href="#检查ruby是否安装" class="headerlink" title="检查ruby是否安装"></a>检查ruby是否安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure><h2 id="安装sqlite3"><a href="#安装sqlite3" class="headerlink" title="安装sqlite3"></a>安装sqlite3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 --version</span><br></pre></td></tr></table></figure><h2 id="安装rails"><a href="#安装rails" class="headerlink" title="安装rails"></a>安装rails</h2><p>linux环境下先安装ruby开发包，<code>apt-get install ruby-dev</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem install rails</span><br><span class="line"></span><br><span class="line">rails --version</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> ruby-on-rails </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase基本使用</title>
      <link href="2020/03/31/develop/hbase/"/>
      <url>2020/03/31/develop/hbase/</url>
      
        <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>线性和模块化的可扩展性</li><li>严格的一致性读写</li><li>动态可配置的表分片</li><li>为使用了HBase表的Hadoop MapReduce任务提供了丰富的基类</li><li>容易使用Java Api访问</li><li>为实时查询提供了块缓存及Bloom Filter</li><li>通过服务端过滤器实现查询下推</li><li>Thrift网关及RestFul 服务器支持XML，protobuf,二进制编码</li><li>支持Jruby-base shell扩展</li><li>支持通过Hadoop测量子系统导出到文件或者ganglia</li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>HBase存储在表中，名称上与RDBMS重叠，但两个有着很大的区别，相反，HBase的表与多维的map类似</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>HBase表由多行组成</p><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>HBase行由行键及一列或者多列数据组成，行是按照存储时的行键的字母排序的，因此，行键的设计十分重要。在这种方式下相关的行尽量的排在相邻。一个通用的行键模式是网站域名，如果存储的域名，那行键应该反向存储，例如(org.apache.www，org.apache.mail，org.apache.jira)。这样，所有的apache相关的域名都存在相邻的位置，便于查找</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常问题集合</title>
      <link href="2020/03/31/util/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>2020/03/31/util/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<span id="more"></span> <h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><ul><li>cmd运行后出现<code>The system cannot find the path specified</code>。一般是启动后自动执行的路径不存在，检查注册表中<code>HKEY_CURRENT_USER\Software\Microsoft\Command Processor</code>是否有配置 <code>AutoRun</code>自动执行路径，并且该路径是否存在；其次检查<code>windows/system32/run</code></li></ul><h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><h2 id="mariaDB4j启动失败问题"><a href="#mariaDB4j启动失败问题" class="headerlink" title="mariaDB4j启动失败问题"></a>mariaDB4j启动失败问题</h2><ul><li><code>dyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib</code><br>对应路径中不存在该文件，可以建软链到指定目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;lib&#x2F;libcrypto.dylib &#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;libcrypto.1.0.0.dylib</span><br><span class="line">ln -s &#x2F;usr&#x2F;lib&#x2F;libssl.dylib &#x2F;usr&#x2F;local&#x2F;opt&#x2F;openssl&#x2F;lib&#x2F;libssl.1.0.0.dylib </span><br></pre></td></tr></table></figure>或者直接安装低版本openssl<br><code>brew install rbenv/tap/openssl@1.0</code></li></ul><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>pem文件格式</p><p>java.security.InvalidKeyException: IOException : algid parse error, not a sequence问题处理<br>错误原因：<br>传入的私钥串privateKey格式不是PKC8格式，<br>其中错误的privateKey是通过openssl生成的私钥，将文件中去掉私钥头（—–BEGIN RSA PRIVATE KEY—–）和私钥尾（—–END RSA PRIVATE KEY—–)<br>不符合格式要求的私钥文件是以—–BEGIN RSA PRIVATE KEY—–开头<br>查阅资料说的是由于用的秘钥生成的是PKCS1的，转换成PKCS8的才行<br>转换方法：<br>openssl pkcs8 -topk8 -inform PEM  -outform PEM -in app_private_key.pem -out apkl.pem -nocrypt</p><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><p>postman 使用pmlib_code加密参数，具体参照script/sign.js<br><a href="https://joolfe.github.io/postman-util-lib/">https://joolfe.github.io/postman-util-lib/</a></p><h1 id="openssl-命令进行签名"><a href="#openssl-命令进行签名" class="headerlink" title="openssl 命令进行签名"></a>openssl 命令进行签名</h1><h2 id="生成签名"><a href="#生成签名" class="headerlink" title="生成签名"></a>生成签名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串签名</span><br><span class="line">echo -n &#39;xxx&#39;  | openssl dgst -sha512 -sign app_private_key_c7.pem -out sign.txt</span><br><span class="line"></span><br><span class="line">文件签名</span><br><span class="line">openssl dgst -sha512 -sign app_private_key_c7.pem -out sign.txt msg.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h2><p><code>openssl base64 -in sign.txt -out signb64.txt</code></p><h2 id="base64-解码"><a href="#base64-解码" class="headerlink" title="base64 解码"></a>base64 解码</h2><p><code>openssl base64 -d -in signature -out sign_decode.txt</code></p><h2 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h2><p><code>openssl dgst -sha512 -verify app_public_key_c7.pem -signature sign.txt msg.txt</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm调优小结</title>
      <link href="2020/03/30/develop/jvm%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/"/>
      <url>2020/03/30/develop/jvm%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>性能调优手段是写程序的一个必要手段，对于java程序来说，一般情况下只要将代码部分优化好就足够达到要求，不过在代码能优化到极致的情况下，我们就需要通过调节jvm参数使得程序进一步提升性能。</p><span id="more"></span><h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>简单的介绍下jvm内存结构及垃圾回收算法</p><p>当代主流虚拟机(Hotspot VM)的垃圾回收都采用分代回收的算法。分代回收是基于不同的对象生命周期不同，所以采用不同的回收方式提升回收效率</p><p>Hotspot VM将内存划分为不同的物理区，如下图所示:<br><img src="/images/jvm_section_1.png" alt=""></p><ul><li>新生代： 除了大对象，堆内对象基本都是在这一代中被创建，其中很多对象的生命周期很短。每次新生代垃圾回收(Minor GC)后只有少量对象能存活，所以JVM采用复制算法，只需要少量的复制成本就可以完成回收。</li></ul><p>新生代内分为三个区：一个Eden区，两个Survivor区，大部分对象都在Eden区中生成，当Eden区满后，当前还存活的对象都会被复制到两个Survivor区中的一个，当其中一个Survivor区满时，不满足”晋升“的对象将被复制到两一个Survivor区。“晋升”指的是：对象每经历一次Minor GC，年龄+1，达到阈值后，对象就会被放到老年代。这个阈值就直接影响着对象在新生代的停留时间，在Serial和ParNew GC这两种垃圾回收器中，可以通过<code>MaxTenuringThreshold</code>的设定，默认15</p><p>JVM中还有“动态年龄计算”的概念。虚拟机在遍历所有对象时，按照年龄从小到大进行累计，当某个年龄的累计超过Survivor区的一半时，就取这个年龄和MaxTenuringThreshold的最小值作为新的阈值。这个概念主要基于以下的考虑：1. 如果按照固定的阈值最为晋升条件，如果阈值过大，会导致Survivor区内存溢出到老年代。2.相同应用在不同的时间表现都可能不同，如果阈值固定，就无法很好适应这个变化</p><ul><li><p>老年代：在新生代中经历N次Minor GC后的对象都处于这一代（包括大对象），该区域对象的存活率高。老年代又称Marjor GC,通常使用标记-清理或者标记-整理算法。整个堆的垃圾回收(包括新生代跟老年代)称为 Full GC。<em>在Hotspot中，除了CMS之外，其他能收集老年代的GC都回同时收集整个GC堆，包括新生代）</em></p></li><li><p>永久代：主要存放元数据，例如Class、Method信息，与垃圾回收的关系不大。<em>在java8后去除了这一代，添加了Meta space</em></p></li></ul><h1 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h1><h2 id="Minor-GC频繁"><a href="#Minor-GC频繁" class="headerlink" title="Minor GC频繁"></a>Minor GC频繁</h2><p>如果新生代所分配到的空间很小，Eden区很快就被填满，就会频繁触发Minor GC，因此适当增大新生代空间来降低Minor GC频率，比如新生代空间增大一倍，Eden区就会增加一倍(倍率不修改)，那么Minor GC次数就会减少一半</p><p>新生代的复制算法主要受对对象扫描的影响，相对来说复制的成本对于虚拟机来说非常低。</p><p>同时对于程序中大部分都是临时对象的情况下，增加新生代空间，可以保证对象有效的被回收，避免因内存不足从而进入到老年代，这样Marjor GC频率也会降低</p><p>对于程序中持久对象居多，那就要适当增加老年代空间</p><h2 id="高峰期发生GC"><a href="#高峰期发生GC" class="headerlink" title="高峰期发生GC"></a>高峰期发生GC</h2><p>前提：老年代采用CMS回收器</p><p>CMS主要涉及如下四个阶段：1.初始标记，该阶段进行可达性分析，标记root能直接关联到的对象，速度很快 2.并发标记，由上一阶段标记过的对象出发，标记所有可达到的对象 3.重新标记(Stop the world)，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记还存活的对象，因为并发标记阶段是和用户线程并行的，这个过程中对象的引用可能会变化，所以这个阶段需要重新标记，防止部分活跃对象又指向了未标记的对象 4.并发清理，并发进行垃圾清理</p><p><img src="/images/jvm_section_2.png" alt=""></p><p>可见重新标记阶段需要扫描堆来判断对象是否存活，这个过程不能仅仅扫描老年代，因为老年代对象可能指向了新生代，正是因为这种跨代引用，jvm必须要扫描整个堆，因此堆中对象的数量就影响回收时间。<br>不过新生代对象大部分是朝生夕灭，所以在重新标记前执行一次Minor GC有助于降低回收时间。</p><p>CMS就是采用了这种方式，在重新标记前增加了一个可中断的并发预清理，该阶段可以被中断，在Eden区使用超过2M时使用(可修改)，在这个阶段执行时等待Minor GC，同时避免Minor GC很久才会触发，增加 <code>CMSMaxAbortablePrecleanTime</code> 默认5s，超过这个时间，就会中断直接扫描整个堆。当然也可以通过参数<code>CMSScavengeBeforeRemark</code>强制每次重新标记前强制进行一次Minor GC</p><p><img src="/images/jvm_section_3.png" alt=""></p><p>CMS是老年代回收器，对于年轻代来说，清理的时候也是需要扫描整个堆来确认对象是否存活。JVM肯定不是全堆扫描的，因为老年代持有年轻代的数量非常小，所以引用了卡表来实现。</p><p><img src="/images/jvm_section_4.png" alt=""></p><p>卡表的具体策略是将老年代划分成若干个大小为512B的卡，本身是一个单字节数组，每个元素对应一张卡，当发生老年代引用新生代时，就在对应的卡上设置，之后Minor GC时直接从卡中识别，总的来说就是设置索引，避免全堆扫描。</p><h2 id="Full-GC扫描"><a href="#Full-GC扫描" class="headerlink" title="Full GC扫描"></a>Full GC扫描</h2><p>Perm空间不足，老年代空间不足，需要晋级的年轻代对象数量超过老年代剩余的空间，主动触发等这几种情况都会触发Full GC。对于Full GC不正常时可按照这几种情况来分析。</p><p>对于jdk8，永久代被元空间取缔，元空间时直接存在内存中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft一致性算法</title>
      <link href="2019/12/24/develop/raft/"/>
      <url>2019/12/24/develop/raft/</url>
      
        <content type="html"><![CDATA[<p>raft是通过管理日志复制的一致性算法。它等价于paxos，并且同样高效，不过在结构上有所不同，raft比paxos更容易理解，因为在实际系统中更容易落地。为追求易理解性，raft将一致性关键要素分成：<strong>领导选举</strong>（leader election),<strong>日志复制</strong>（log replication）,以及<strong>安全性</strong>，并执行更高级别的一致性必须考虑的状态数。从用户学习的效果来看，raft更容易被掌握。此外，raft引入了一种新机制来支持集群成员变更，以重叠过半数来保证安全性。</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一致性算法让多台机器组成一个统一连贯的整体，而不受某些成员故障的影响。因此，这类算法在构建高可用海量软件系统中扮演者重要角色，过去几十年，paxos算法一直是这个领域的主宰，大部分一致性算法要么基于paxos要么从其衍生而来，paxos也成为一致性算法教学的重要工具。</p><p>raft用到了不少设计技巧，包括：<strong>问题分解</strong>（分解成领袖选举，日志复制以及安全性三个子问题），以及<strong>状态规模缩减</strong>（与paxos相比，raft降低了不确定性以及服务间的不一致的可能）</p><p>raft与现有的一致性算法有不少相似之处，但以下特征有明显的不同：</p><ul><li>强领袖：与其他一致性算法相比，raft采用了一种更强势的领袖模式。例如，日志条目只从领袖流向其他服务器。这样坐简化了日志复制管理。</li><li>领袖选举：raft采用了<strong>随机计时器</strong>实现领袖选举。这种做法仅在服务器心跳基础上加了少量的处理机制，既可以简单迅速的解决选举冲突。</li><li>成员变更：raft采用联合一致性(jolin consensus)，这个特性使得集群可以在配置调整时不中断服务。</li></ul><h1 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h1><p>一致性算法通常在<strong>复制状态机</strong>（replicated state machines）上下文产生。这种方法要求在服务器集群上运行一样的状态机副本，就算一些服务器故障也不受影响。复制状态机用于解决分布式系统中的容错问题。</p><p><img src="/images/consensus/raft1.png" alt=""></p><p>复制状态机一般通过日志复制来实现，每台服务器用一个日志保存命令序列，并由状态机依次执行。每个日志包含相同的命令，顺序也一样，因此每个状态机处理的命令序列都是一样的，由于状态机时可确定的，计算将得到相同的状态并输出相同的结果。</p><p>确保日志副本一致性是一致性算法的主要工作。一致性模块接收来自客户端的命令并写到本地日志，它同时与其他服务器通讯，以保证每个日志最终以相同的顺序包含相同的请求，即便有服务器故障也是如此。一旦命令正确的复制，每台服务器将按照顺序进行处理，并将结果返回给客户端，这样一来服务器集群便形成单一的高可用状态机。</p><p>一个可用于生产系统的一致性算法需要以下特性：</p><ul><li>在所有非拜占庭条件下保证安全性（不返回错误结果），包括网络延迟，分区，丢包等等</li><li>只要过半数服务器正常，就可以保证系统的可用性，因此，一个由5台服务器组成的集群，能够容忍任意两台服务器故障，服务器关机也认为是故障；服务器恢复后可以从持久存储中恢复状态并重新加入集群</li><li>不依赖时许保证日志一致性：时钟故障，消息延迟最多影响可用性</li><li>一般情况下，只要过半机器相应相关远程调用，命令便算完成；少部分机器相应缓慢不能影响系统性能</li></ul><h1 id="raft一致性算法"><a href="#raft一致性算法" class="headerlink" title="raft一致性算法"></a>raft一致性算法</h1><p>实现思路：选举一个<strong>领袖节点</strong>，由该节点全权负责管理复制日志。领袖服务器从客户端接收日志条目，复制到其他服务器上并在合适的时机通知他们应用到状态机。引入领袖这个角色后，对复制日志的管理就变得简单了，因为领袖可以自行决定并保存条目，无须与其他服务器协商，数据流也简单，当其与其他服务器失去联系后会进行重新选举。</p><h2 id="raft要点"><a href="#raft要点" class="headerlink" title="raft要点"></a>raft要点</h2><p>所有服务器均保存以下<strong>持久状态</strong>（响应RPC请求前需要更新到持久性存储介质）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器当前任期编号，及其所见的最新任期编号（第一次启动初始化0，后续单调递增）</td></tr><tr><td>voteFor</td><td>在当前任期得到选票的候选人ID,不存在则为空</td></tr><tr><td>log[]</td><td>日志条目线性表；每个条目包含一条状态机命令以及领袖接收到命令的任期编号（索引从1开始）</td></tr></tbody></table><p>所有服务器保存以下 <strong>非持久状态</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>commitIndex</td><td>最后一个已提交条目的索引（初始化为0 ，后续单调递增</td></tr><tr><td>lastAppied</td><td>最后一个已经应用到状态机条目的索引（初始化为0，后续单调递增</td></tr></tbody></table><p>领袖 还保存以下<strong>非持久状态</strong>（选举后重新初始化）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>记录发送到每个服务器的下一个日志条目的索引（初始化为领导者的上一个日志索引+ 1）</td></tr><tr><td>matchIndex[]</td><td>记录各服务器最后复制条目的索引（初始化为0 ，后续单调递增</td></tr></tbody></table><h2 id="AppendEntries-RPC"><a href="#AppendEntries-RPC" class="headerlink" title="AppendEntries RPC"></a>AppendEntries RPC</h2><p>领袖调用该RPC往其他服务器复制日志条目，也用于交换心跳</p><p>该RPC所需参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>term</td><td>领袖任期</td></tr><tr><td>leaderId</td><td>领袖ID,属下后续可据此重定向客户端请求</td></tr><tr><td>prevLogIndex</td><td>上一条目索引</td></tr><tr><td>prevLogTerm</td><td>上一条目任期</td></tr><tr><td>entries[]</td><td>被复制日志条目（心跳则为空；出于性能考虑可以批量发送</td></tr><tr><td>leaderCommit</td><td>领袖已提交条目索引</td></tr></tbody></table><p>返回</p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>term</td><td>接收者当前任期，领袖据此更新自身任期</td></tr><tr><td>success</td><td>如果属下包含于prevLongIndex和prevLogTerm吻合的条目，则返回成功</td></tr></tbody></table><p>接收服务器需实现以下处理逻辑：</p><ol><li>如果任期编号比本地小 <code>term &lt; currentTerm</code> 则返回失败</li><li>如果属下在prevLongIndex 索引处不包含prevLogTerm任期条目，则返回失败</li><li>如果属下有条目与新条目冲突（索引相同任期不同），则删除该条目以及所有后续条目</li><li>追加所有未在日志中的新条目</li><li>如果 leaderCommit &gt; commitIndex 则将commitIndex更新为leaderCommit以及最后新条目索引的较小值</li></ol><h2 id="RequestVote-RPC"><a href="#RequestVote-RPC" class="headerlink" title="RequestVote RPC"></a>RequestVote RPC</h2><p>候选人调用该RPC收集选票</p><p>参数列表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>term</td><td>候选人任期</td></tr><tr><td>candidateId</td><td>候选人id</td></tr><tr><td>lastLogIndex</td><td>日志最后条目索引</td></tr><tr><td>lastLogTerm</td><td>日志最后条目任期</td></tr></tbody></table><p>返回</p><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>term</td><td>接收者当前任期，候选人据此可更新自身任期</td></tr><tr><td>voteGranted</td><td>是否接收当前候选人的投票</td></tr></tbody></table><p>接收服务器需要实现以下逻辑：</p><ol><li>如果任期编号小于当前任期编号，<code>term &lt; currentTerm</code>,拒绝该请求</li><li>如果接收者 votedFor为空或者等于candidateId,<strong>而且候选人日志至少与接收者本地一样新</strong>，则投出选票</li></ol><h2 id="服务器规则"><a href="#服务器规则" class="headerlink" title="服务器规则"></a>服务器规则</h2><p>所有服务器</p><ul><li>如果 <code>commitIndex &gt; lastApplied</code>,则自增lastApplied,并将<code>log[lastApplied]</code>条目应用到状态机</li><li>如果RPC请求或响应所带任期比当前大 <code>T &gt; currentTerm</code> 则更新当前任期 <code>currentTerm == T</code>,并转成属下</li></ul><p>属下：</p><ul><li>响应来自领袖及候选人的RPC请求</li><li>选举超时时间耗尽而未收到领袖的AppendEntries RPC请求，且未给其他候选人投票，则转为候选人</li></ul><p>候选人：</p><ul><li>转换到候选人后开始选举<ul><li>自增当前任期</li><li>为自己投票</li><li>重置选举计时器</li><li>向所有其他服务器发起 RequestVote RPC请求</li></ul></li><li>如果收到过半数服务器的选票，则成为领袖</li><li>如果收到新领袖 AppendEntries RPC，转成属下</li><li>如果选举（计时器）超时，则重新发起选举</li></ul><p>领袖：</p><ul><li>赢得选举后，空闲时循环发送 AppendEntries RPC请求（心跳），避免其他服务器选举超时</li><li>收到客户端命令后往本地日志追加新条目，等条目应用到状态机后才向客户端响应结果（<strong>先追加到本地日志，然后往其他机器复制，过半机器复制成功后应用状态，成功后响应客户端</strong>）</li><li>如果最后条目索引大于等于属下下个索引，即<code>lastIndex &gt;= nextIndex</code>，则发起AppendEntries RPC追加从nextIndex开始的日志<ul><li>请求成功，则更新属下nextIndex以及matchIndex</li><li>请求因日志不一致而失败；下调nextIndex并重试</li></ul></li><li>更新<code>commitIndex = N</code>,如果数值N同时满足以下条件<ul><li><code>N &gt; commitIndex</code></li><li>过半属下matchIndex 不小于 N,及<code>matchIndex[i] &gt;= N</code></li><li><code>log[N].term == currentTerm</code></li></ul></li></ul><h2 id="关键性质"><a href="#关键性质" class="headerlink" title="关键性质"></a>关键性质</h2><ul><li>选举安全性：任意任期内最多选举出一个领袖</li><li>领袖只追加：领袖只能追加新日志条目；不能修改也不能删除已有条目</li><li>日志拼接性：两个日志某个条目索引相同且任期相同，则前面条目也完全相同</li><li>领袖完整性：日志条目只要被提交，后续任期领袖一定包含该条目</li><li>状态机安全性：服务器将日志条目应用到状态机后，其他服务器无法在相同索引下应用另一个不同条目 </li></ul><p>raft集群由若干服务器组成，任何时刻每台服务器都处于以下三种状态：</p><ul><li>领袖（leader）</li><li>属下（follower)</li><li>候选人（candidate）<br>正常情况下，刚好有一个领袖，而所有其他服务器则都是属下。属下节点是被动的：他们自身不发起任何请求，相反只是简单响应领袖以及候选人的请求。领袖节点负责处理所有客户端请求（客户端请求属下节点将被重定向到领袖节点）。候选人则是用来选举新的领袖。</li></ul><p><img src="/images/consensus/a63f12ba8d5b7d68ca1a016257370022.png" alt=""><br>图中 属下节点之响应来自其他服务器的请求，如果有一个属下节点没有收到任何消息，则自身升级成候选人发起一次选举，收到集群过半票数则将成为新的领袖。</p><p>raft将时间划分成任意的任期（term)，以连续整数进行编号，每个任期以一次选举开始，选举中一台或者堕胎候选人尝试成为领袖。一个候选人赢得选举后，在任期内都处于领袖身份。在某些场景下会以<strong>分裂投票</strong>结束。这种情况下，任期因领袖缺失而结束；raft确保任意任期内最多只有一个领袖。</p><p><img src="/images/consensus/d8a50a2705e4b3d0bac2084961d9e22d.png" alt=""></p><p>服务器可能在不同时间点观察到任期更替，某些情况下也可能观察到选举。甚至是整个任期。任期在raft中扮演<strong>逻辑时钟</strong>的角色，辅助服务器检查过期信息，例如领袖。每台服务器保存当前任期号，该编号单调递增。服务器通讯交换当前任期编号；某台服务器任期编号比其他服务器小，则将更新自己的任期编号。如果候选人或者领袖发现自身任期过期，则立即将自身转成属下状态，如果某台服务器收到一个带旧编号的请求，则拒绝该请求。</p><p>raft服务器通过RPC通讯，一致性算法需要两种不同的RPC，候选人在选举期间调用<strong>RquestVote</strong>发起投票；选举成功后调用<strong>AppendEntries</strong>来复制日志并保持心跳。服务器在没有收到响应时及时重发RPC并通过并发提升性能。</p><h2 id="领袖选举"><a href="#领袖选举" class="headerlink" title="领袖选举"></a>领袖选举</h2><p>Raft采用<strong>心跳机制</strong>来触发领袖选举，服务器启动后以属下角色运行。只要它不断收到领袖或者候选人的RPC请求，则保持属下状态不变。领袖发送周期性的心跳，以保持领导权。如果属下超过一定时间（<strong>超时时间</strong>）没有收到任何心跳，则发起新的选举。</p><p>为发起选举，属下自身自身任期，并转换成候选人。随后为自身投票，同时向其他服务器发起<strong>RequestVote</strong>请求，候选人持续这个状态直到以下情形：</p><ul><li>候选人赢得选举</li><li>另一台机器以领袖身份连接候选人。</li><li>超过设定时间但未选举成功</li></ul><p>如果后台人在同个任期内收到过半数的投票，它将赢得选举。每台机器在一个任期内最多只能给一个候选人赢得选举。一旦候选人赢得选举，它将成为领袖。随后它向其他服务器发送心跳信息，建立领导权并阻止新的选举。</p><p>在等待投票时，候选人可能收到其他服务器为宣示领导权而发来的<strong>AppendEntries</strong>请求，如果来源领袖任期至少与候选人一样大，候选人便认为领袖合法，并重回属下身份，相反拒绝该请求，保持候选人状态。</p><p>第三种情况是：候选人既没有赢得选举，也没有输掉选举：如果多个属下同时转变成候选人，选票可能分裂，导致谁都无法获得过半选票。这种情况下候选人会超时并开启一次新的选举–自增任期并开始下一轮<strong>RequestVote</strong>，然而如果没有额外的信息，选票分裂可能会不断出现。</p><p>Raft采用<strong>随机化选举超时间</strong>，分裂投票很罕见，就算出现也可以迅速解决。首先是防止投票分裂–在固定区间内（如150~300ms）随机一个超时时间，这种做法的好处是服务器超时时间被分散，大部分情况下只有一台机器超时；它将赢得选举并在其他机器超时前发送心跳。其次是应对分裂，做法也是类似。每个候选人在选举开始时开启一个随机定时器，时间耗尽后才能发起下一次选举，错开选举时间。</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>领袖被选举出来之后，开始服务。每个客户端氢气包含一个可以被复制状态机执行的命令。领袖将命令置为新条目追加到本地日志，然后发起<strong>AppendEntries</strong>请求往其他机器复制该条目。一旦条目安全的复制（复制到过半机器），领袖将条目应用到自身的状态机并执行结果告知客户端。如果属下节点宕机、响应慢、网络丢包，领袖将不断重试，直到该节点日志同步（就算过半数已经响应并响应给客户端，后续还是会继续这个重试步骤）</p><p><img src="/images/consensus/0a7a377ab90034e62883a6049bd6d73e.png" alt=""><br>每个日志条目包含一个状态及命令，以及领袖节点收到该命令时的任期编号。任期编号用于检测日志的一致性，以保证<a href="#关键性质">关键性质</a>，日志中还包含一个整数索引编号，以区分其在日志中的位置。</p><p>领袖决定何时将日志条目安全应用到状态机，这样的条目成为已提交（committed)。raft保证所有已提交的条目都是持久的，可以被所有可用状态机执行。一旦日志条目被其创建领袖复制到过半机器，便视作已提交。与此同时，领袖日志内所有牵制条目，也视作<strong>已提交</strong>。领袖追踪其知悉的已提交条目的最大索引，并在后续的<strong>AppendEntries</strong>告知其他服务器，属下发现日志条目已提交后，将其应用到状态机。</p><p>设计日志的目的是让不同机器上的日志保持高度一致。这样简化了系统行为并使其更加可以预测，这个是确保安全性的关键因素。raft保证以下两个特性，构成日志拼接性：</p><ul><li>如果不同日志内两个条目的索引以及任期编号相同，那么存储的命令也相同</li><li>如果不同日志内两个条目的索引以及任期编号相同，那么所有前置条目也都相同</li></ul><p>第一个性质：给定任期内，领袖最多只能创建一条给定索引的日志条目；而且条目在日志的顺序不能修改。第二个性能由<strong>AppendEntries</strong>请求进行简单一致性检查来保证。发起<strong>AppendEntries</strong>，领袖也会带上前一日志条目的索引以及任期编号。属下节点如果找不到对应的条目，它将拒绝新条目，一致性检查递归的发挥作用：初始时，日志状态为空，满足日志拼接性；一致性检查确保日志扩展时继续保证日志的拼接性。因此，只要<strong>AppendEntries</strong>成功返回，领袖便知道属下日志至少到新条目为止与自己保持一致。</p><p>正常情况下领袖与属下是一致的。然而领袖故障可能导致日志不一致（例如旧领导还没将日志复制到其他机器）<br>日志缺失或者多余的情况下会持续若干个任期<br><img src="/images/consensus/8e91b9306a84ae3e3685d75ae024ebfe.png" alt=""><br>当顶部的领袖节点启动后，从属节点可能存在的各种可能：属下节点可能缺失部分日志（a~b）；也可能包含多余未提交日志（c~d）；或者同时出现（e~f）。情景f可能是这样产生的：该服务器是任期2的领袖，追加了日志后但是还没提交就宕机了；然后其迅速重启，在任期3继续担任领袖，又追加了部分日志，在提交前又宕机，错过了之后的几个任期。</p><p>raft算法中，领袖强制其他服务器复制自己的日志，以此应对不一致，这就意味着需要用领袖上的条目来覆盖属下日志中有冲突的部分，日志覆盖是安全的，只须多加一条约束。</p><p>为了让属下日志与自身保持一致，领袖需要找到双方最后一个匹配的条目，从该节点开始删除属下所有不一致的条目，并发送后续条目。这些操作根据<strong>AppendEntries</strong>返回的一致性检查结果视情况执行。领袖为每台属下维护一个 nextIndex变量，保存下一个发送给属下的日志编号。当领袖刚开始服务时，将nextIndex设置为自己日志中的下一个条目，如果属下日志与其不一致，下一次的<strong>AppendEntries</strong>一致性检查将失败。请求失败后领袖将降低nextIndex并重试请求，最终达到双方都匹配的节点。这时<strong>AppendEntries</strong>成功，请求将删除属下冲突的条目并从领袖日志追加新的条目，一旦成功，意味着属下与领袖的日志达到一致，任期内后续都会一致。</p><p>在这种机制下，领袖开始服务后不需要任何特殊的操作保证一致性。只需要正常开始工作，经过<strong>AppendEntries</strong>失败后调整后将自动保持一致，领袖者不会覆盖自身及删除日志条目</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>然后当前还不能保证每台状态机刚好执行相同的命令序列。例如一台属下可能在领袖提交新日志条目时故障，恢复后被选举为新的领袖，覆盖了旧领袖追加的条目。造成不同状态机执行了不同的命令序列。</p><h3 id="选举约束"><a href="#选举约束" class="headerlink" title="选举约束"></a>选举约束</h3><p>任何依赖领袖的一致性算法，领袖必须拥有所有已提交的日志条目。raft采用了简化的做法，<strong>选举保证新领袖必须包含先前任期所有已提交条目</strong>，无须传输缺失的条目，这就意味着条目只有一个流向，从领袖流向属下，领袖不会覆盖已存在的条目</p><p>raft通过选举过程<strong>阻止候选人赢得选举</strong>，除非它拥有所有已提交的日志。候选人想赢得选举必须与集群内大多数机器通讯，这就意味着每个已提交条目必须出现在这些机器内至少有一台。只要候选人日志至少与其他大多数机器一样新，它便拥有所有已提交条目。<strong>RequestVote</strong> 实现了这个约束：该请求带有候选人日志信息，其他节点发现其落后于自己的日志，则拒绝投票</p><p>raft以日志最后条目的索引以及任期判断日志更新。如果最后条目的任期不同，则任期靠后的更新，如果任期相同索引不同，索引越大越新</p><h3 id="提交前任条目"><a href="#提交前任条目" class="headerlink" title="提交前任条目"></a>提交前任条目</h3><p>之前说过只要日志被复制到大部分的机器，领袖便提交该条目。如果领袖故障而导致还没来得及提交，后续的领袖将尝试复制该条目。然而领袖无法确定先前任期的条目是否提交，就算复制过半数，旧日志复制过半数也可能被新领袖覆盖</p><p><img src="/images/consensus/fa933b96f1cb688befc825c3d82c167d.png" alt=""><br>如图，时刻a，s1是领袖，只完成了索引2条目的复制，时刻b，s1故障；s5被选为任期3的领袖（取得3，4的选票）并在索引2处接收一个新条目。时刻c，s5故障，s1重启被选为新的领袖，继续进行复制，这时，任期2的日志被复制到过半机器，但是没有提交。如果s1在时刻d挂掉，s5重新被选为领袖（s2-4的选票），将用自己任期3的条目进行覆盖。但是s1故障前将当前任期的日志条目复制过半机器，如时刻e，那么该条目就算完成提交（s5便无法赢得选举）。此时，所有前置日志条目也都完成提交。</p><p>为了解决这个问题，raft选择<strong>不继续复制提交前任条目</strong>，只有领袖当前任期的日志条目才会持续复制提交；一旦当前任期条目完成提交，所有更早的日志也被提交（日志拼接性）。</p><h3 id="安全性论证"><a href="#安全性论证" class="headerlink" title="安全性论证"></a>安全性论证</h3><p>可以使用反证法来证明：先假设领袖完整性不成立，由此退到处矛盾结论。假设任期T领袖在任期内提交了一个日志条目e，而后续任期领袖没有保存该条目，设领袖不包含条目e的最小任期是U（<code>U &gt; T</code>），则：</p><ol><li>任期U领袖选举时就已经缺少了条目e（领袖不删除或者覆盖自己的日志）</li><li>任期T领袖将条目e复制过半数，而任期U领袖又收到过半投票数，因此至少有一台服务器即接收了条目e，又给任期U投票，这个也是不成立的<br><img src="/images/consensus/6b7f4bdd4ab11b6c9c348307778753f7.png" alt=""></li><li>投票人必须在任期U领袖投票前，便已接受任期T领袖提交的日志条目。否则它将拒绝任期T领袖的<strong>AppendEntries</strong>，因为U的任期大</li><li>根据假设，任期T到U之间的领袖均包含条目e，因此投票人在给任期U领袖投票时一定还包含条目e。因为领袖永远不会删除自己的日志，属下只有在条目于领袖有冲突才会删除</li><li>投票人给任期U领袖投票，说明任期U领袖的日志至少和投票人一样新。进一步推理存在两种可能的场景，均是矛盾的。</li><li>首先，如果投票人于任期U领袖的日志最后任期相同，那么领袖日志至少于投票一样长，这与假设矛盾，因为假设中投票人包含条目e而任期U不包含</li><li>还有一种可能的情况：任期U的领袖日志最后任期只能比投票人大。由于投票人包含了任期T条目e，其日志最后任期至少是T，因为任期U领袖日志的最后任期比T大。根据假设，提交任期U领袖最后一个日志条目的领袖，必须包含条目e，根据日志拼接性，任期U内一定包含e</li></ol><h2 id="属下与候选人故障"><a href="#属下与候选人故障" class="headerlink" title="属下与候选人故障"></a>属下与候选人故障</h2><p>如果属下与候选人故障，那么<strong>AppendEntries</strong>请求失败，raft采用的机制是不断重试，重启后收到请求恢复正常。如果故障时正在处理请求，但是还没有返回，恢复后还会收到相同的RPC，由于raft RPC请求是幂等的，因此重试不会造成任何影响，例如属下发现条目已经在本地中，则会忽略。</p><h2 id="时序与可用性"><a href="#时序与可用性" class="headerlink" title="时序与可用性"></a>时序与可用性</h2><p>raft还有一个条件：安全性不依赖时序：系统不能因为某些事件快于慢于预期便发生错误结果。然而 可用性（系统能够及时响应客户端请求）却不可避免的依赖时序。例如，如果消息交换耗时比两次机器故障间隔事件还长，候选人无法撑到选举胜出；没有一个稳定的领袖，raft便不能工作。</p><p>只要以下时序条件成立，raft便可以选举并维持一个稳定的领袖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF </span><br></pre></td></tr></table></figure></p><ul><li>broadcastTime: 服务器往集群所有服务器发起一轮并行的RPC请求并收到响应的平均时间</li><li>electionTime：选举超时时间</li><li>MTBF：单台机器故障的平均时间间隔</li></ul><p>广播时间必须比选举时间小一个数量级，以便领袖可以靠发送心跳信息确保属下不发起新的选举；与选举随机超时时间配合，这个规则确保投票分裂不太会发生。选举超时时间必须比MTBF小于若干数量级，这样系统运行才稳定。</p><h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>不过在实践过程中，集群可能会调整，例如替换故障机器或者调整副本数。</p><p>安全配置的前提是：调整过程中不能出现两个领袖的情况。很不幸的是任何服务器直接从旧配置切换到新配置都是不安全的。由于所有服务器不可能同时切换，集群在调整过程中可能分化处两个互斥的过半数集合</p><p><img src="/images/consensus/2f2d0eea6c824382b881ad77dcc38061.png" alt=""><br>直接从一份配置切换到另一份配置是不安全的，因为不同服务器可能在不同时间点切换</p><p>为了确保安全性，配置分为两个阶段进行。实现两阶段机制有很多种方式可选。譬如有些系统在第一阶段禁用旧配置并停止更新客户端请求，然后第二阶段启用新配置。在raft种，集群先切换到一个 联合一致性的中间配置，结合旧配置和新配置</p><ul><li>日志条目同时复制到新旧配置的所有机器</li><li>新旧机器配置种任一台均可能成为领袖</li><li>决议（选举和日志提交）必须同时由新旧机器过半数产生</li></ul><blockquote><p><a href="/files/raft.pdf">raft论文</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo负载均衡</title>
      <link href="2019/12/20/develop/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2019/12/20/develop/dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<p>LoadBalance 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是可以接触到的，比如 Nginx。在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。</p><span id="more"></span><p>在dubbo中所有负载均衡都是从继承<code>AbstractLoadBalance</code>，该类实现了<code>LoadBalance</code>接口，内部封装了一些公共的方法</p><ul><li><p>select方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">if (invokers.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F;当实例只有一个，不通过负载均衡</span><br><span class="line">    return invokers.get(0);</span><br><span class="line">&#125;</span><br><span class="line">return doSelect(invokers, url, invocation);</span><br></pre></td></tr></table></figure></li><li><p>calculateWarmupWeight<br>计算程序预热后的权重值，保证当前服务运行时长少于预热时长时，对服务进行降权，避免程序刚开始运行就处于高负载的情况。服务预热时一个优化手段，与此类似还有jvm预热。主要目的是让服务”低功率”运行一段时间，让其逐渐升至最佳状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123;</span><br><span class="line">        int ww &#x3D; (int) ( uptime &#x2F; ((float) warmup &#x2F; weight));</span><br><span class="line">        return ww &lt; 1 ? 1 : (Math.min(ww, weight));</span><br><span class="line">&#125;</span><br><span class="line">int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前服务的权重值</span><br><span class="line">    int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">    if (weight &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取启动时间</span><br><span class="line">        long timestamp &#x3D; invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);</span><br><span class="line">        if (timestamp &gt; 0L) &#123;</span><br><span class="line">            &#x2F;&#x2F;计算运行时间</span><br><span class="line">            long uptime &#x3D; System.currentTimeMillis() - timestamp;</span><br><span class="line">            if (uptime &lt; 0) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;获取预热时长，默认10分钟</span><br><span class="line">            int warmup &#x3D; invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">            if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                weight &#x3D; calculateWarmupWeight((int)uptime, warmup, weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(weight, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h1><p>一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提出的，算法提出之初是用于大规模缓存系统的负载均衡。它的工作过程是这样的，首先根据 ip 或者其他的信息为缓存节点生成一个 hash，并将这个 hash 投射到 [0, 232 - 1] 的圆环上。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后查找第一个大于或等于该 hash 值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash 值的缓存节点即可。大致效果如下图所示，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项。比如下面绿色点对应的缓存项将会被存储到 cache-2 节点中。由于 cache-3 挂了，原本应该存到该节点中的缓存项最终会存储到 cache-4 节点中。</p><p><img src="/images/dubbo/consistent-hash.jpg" alt=""><br>以下是一致性hash在dubbo中的应用，上图中的缓存节点也换成了dubbo服务提供者</p><p><img src="/images/dubbo/consistent-hash-invoker.jpg" alt=""></p><p>这里同一个节点属于同一个服务，主要是避免数据发生倾斜。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。比如：<br><img src="/images/dubbo/consistent-hash-data-incline.jpg" alt=""><br>如上，由于 Invoker-1 和 Invoker-2 在圆环上分布不均，导致系统中75%的请求都会落到 Invoker-1 上，只有 25% 的请求会落到 Invoker-2 上。解决这个问题办法是引入虚拟节点，通过虚拟节点均衡各个节点的请求量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">    String methodName &#x3D; RpcUtils.getMethodName(invocation);</span><br><span class="line">    String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + methodName;</span><br><span class="line">    &#x2F;&#x2F;获取invokes的hash值</span><br><span class="line">    int identityHashCode &#x3D; System.identityHashCode(invokers);</span><br><span class="line">    ConsistentHashSelector&lt;T&gt; selector &#x3D; (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    &#x2F;&#x2F;如果invokes的hash值发生改变，说明可用服务发生改变，需要重新计算节点位置</span><br><span class="line">    if (selector &#x3D;&#x3D; null || selector.identityHashCode !&#x3D; identityHashCode) &#123;</span><br><span class="line">        selectors.put(key, new ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">        selector &#x3D; (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    return selector.select(invocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final class ConsistentHashSelector&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 TreeMap 存储 Invoker 虚拟节点</span><br><span class="line">    private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">    private final int replicaNumber;</span><br><span class="line"></span><br><span class="line">    private final int identityHashCode;</span><br><span class="line"></span><br><span class="line">    private final int[] argumentIndex;</span><br><span class="line"></span><br><span class="line">    ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">        this.virtualInvokers &#x3D; new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">        this.identityHashCode &#x3D; identityHashCode;</span><br><span class="line">        URL url &#x3D; invokers.get(0).getUrl();</span><br><span class="line">        &#x2F;&#x2F; 获取虚拟节点数，默认为160</span><br><span class="line">        this.replicaNumber &#x3D; url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">        &#x2F;&#x2F; 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算</span><br><span class="line">        String[] index &#x3D; Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">        argumentIndex &#x3D; new int[index.length];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index.length; i++) &#123;</span><br><span class="line">            argumentIndex[i] &#x3D; Integer.parseInt(index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            String address &#x3D; invoker.getUrl().getAddress();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; replicaNumber &#x2F; 4; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span><br><span class="line">                byte[] digest &#x3D; md5(address + i);</span><br><span class="line">                &#x2F;&#x2F; 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span><br><span class="line">                for (int h &#x3D; 0; h &lt; 4; h++) &#123;</span><br><span class="line">                    &#x2F;&#x2F; h &#x3D; 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span><br><span class="line">                    &#x2F;&#x2F; h &#x3D; 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span><br><span class="line">                    &#x2F;&#x2F; h &#x3D; 2, h &#x3D; 3 时过程同上</span><br><span class="line">                    long m &#x3D; hash(digest, h);</span><br><span class="line">                    &#x2F;&#x2F; 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中，</span><br><span class="line">                    &#x2F;&#x2F; virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ConsistentHashSelector 的构造方法执行了一系列的初始化逻辑，比如从配置中获取虚拟节点数以及参与 hash 计算的参数下标，默认情况下只使用第一个参数进行 hash。需要特别说明的是，ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不 关系权重，因此使用时需要注意一下。</span><br><span class="line"></span><br><span class="line">在获取虚拟节点数和参数下标配置后，接下来要做的事情是计算虚拟节点 hash 值，并将虚拟节点存储到 TreeMap 中。到此，ConsistentHashSelector 初始化工作就完成了。接下来，我们来看看 select 方法的逻辑。</span><br><span class="line"></span><br><span class="line">public Invoker&lt;T&gt; select(Invocation invocation) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将参数转为 key</span><br><span class="line">    String key &#x3D; toKey(invocation.getArguments());</span><br><span class="line">    &#x2F;&#x2F; 对参数 key 进行 md5 运算</span><br><span class="line">    byte[] digest &#x3D; md5(key);</span><br><span class="line">    &#x2F;&#x2F; 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span><br><span class="line">    &#x2F;&#x2F; 寻找合适的 Invoker</span><br><span class="line">    return selectForKey(hash(digest, 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">    &#x2F;&#x2F; 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span><br><span class="line">    Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.tailMap(hash, true).firstEntry();</span><br><span class="line">    &#x2F;&#x2F; 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry &#x3D; null，</span><br><span class="line">    &#x2F;&#x2F; 需要将 TreeMap 的头节点赋值给 entry</span><br><span class="line">    if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">        entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回 Invoker</span><br><span class="line">    return entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h1><p>RandomLoadBalance 是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为5000次，服务器 B 被选中的次数约为3000次，服务器 C 被选中的次数约为2000次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class RandomLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;random&quot;;</span><br><span class="line"></span><br><span class="line">    private final Random random &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span><br><span class="line">        &#x2F;&#x2F; 第二是检测每个服务提供者的权重是否相同</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            &#x2F;&#x2F; 累加权重</span><br><span class="line">            totalWeight +&#x3D; weight;</span><br><span class="line">            &#x2F;&#x2F; 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span><br><span class="line">            &#x2F;&#x2F; 不相同的话，则将 sameWeight 置为 false。</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">                sameWeight &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span><br><span class="line">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            &#x2F;&#x2F; 随机获取一个 [0, totalWeight) 区间内的数字</span><br><span class="line">            int offset &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span><br><span class="line">            &#x2F;&#x2F; 举例说明一下，我们有 servers &#x3D; [A, B, C]，weights &#x3D; [5, 3, 2]，offset &#x3D; 7。</span><br><span class="line">            &#x2F;&#x2F; 第一次循环，offset - 5 &#x3D; 2 &gt; 0，即 offset &gt; 5，</span><br><span class="line">            &#x2F;&#x2F; 表明其不会落在服务器 A 对应的区间上。</span><br><span class="line">            &#x2F;&#x2F; 第二次循环，offset - 3 &#x3D; -1 &lt; 0，即 5 &lt; offset &lt; 8，</span><br><span class="line">            &#x2F;&#x2F; 表明其会落在服务器 B 对应的区间上</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 让随机值 offset 减去权重值</span><br><span class="line">                offset -&#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">                if (offset &lt; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 返回相应的 Invoker</span><br><span class="line">                    return invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span><br><span class="line">        return invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">RandomLoadBalance 的算法思想比较简单，在经过多次请求后，能够将调用请求按照权重值进行“均匀”分配。当然 RandomLoadBalance 也存在一定的缺点，当调用次数比较少时，Random 产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上。这个缺点并不是很严重，多数情况下可以忽略。RandomLoadBalance 是一个简单，高效的负载均衡实现，因此 Dubbo 选择它作为缺省实现。</span><br></pre></td></tr></table></figure></p><h1 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h1><p>LeastActiveLoadBalance 翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。举个例子说明一下，在一个服务提供者集群中，有两个性能优异的服务提供者。某一时刻它们的活跃数相同，此时 Dubbo 会根据它们的权重去分配请求，权重越大，获取到新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class LeastActiveLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;leastactive&quot;;</span><br><span class="line"></span><br><span class="line">    private final Random random &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        &#x2F;&#x2F; 最小的活跃数</span><br><span class="line">        int leastActive &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量</span><br><span class="line">        int leastCount &#x3D; 0; </span><br><span class="line">        &#x2F;&#x2F; leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息</span><br><span class="line">        int[] leastIndexs &#x3D; new int[length];</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 第一个最小活跃数的 Invoker 权重值，用于与其他具有相同最小活跃数的 Invoker 的权重进行对比，</span><br><span class="line">        &#x2F;&#x2F; 以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等</span><br><span class="line">        int firstWeight &#x3D; 0;</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历 invokers 列表</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; invokers.get(i);</span><br><span class="line">            &#x2F;&#x2F; 获取 Invoker 对应的活跃数</span><br><span class="line">            int active &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            &#x2F;&#x2F; 获取权重 - ⭐️</span><br><span class="line">            int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class="line">            &#x2F;&#x2F; 发现更小的活跃数，重新开始</span><br><span class="line">            if (leastActive &#x3D;&#x3D; -1 || active &lt; leastActive) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用当前活跃数 active 更新最小活跃数 leastActive</span><br><span class="line">                leastActive &#x3D; active;</span><br><span class="line">                &#x2F;&#x2F; 更新 leastCount 为 1</span><br><span class="line">                leastCount &#x3D; 1;</span><br><span class="line">                &#x2F;&#x2F; 记录当前下标值到 leastIndexs 中</span><br><span class="line">                leastIndexs[0] &#x3D; i;</span><br><span class="line">                totalWeight &#x3D; weight;</span><br><span class="line">                firstWeight &#x3D; weight;</span><br><span class="line">                sameWeight &#x3D; true;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当前 Invoker 的活跃数 active 与最小活跃数 leastActive 相同 </span><br><span class="line">            &#125; else if (active &#x3D;&#x3D; leastActive) &#123;</span><br><span class="line">            &#x2F;&#x2F; 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标</span><br><span class="line">                leastIndexs[leastCount++] &#x3D; i;</span><br><span class="line">                &#x2F;&#x2F; 累加权重</span><br><span class="line">                totalWeight +&#x3D; weight;</span><br><span class="line">                &#x2F;&#x2F; 检测当前 Invoker 的权重与 firstWeight 是否相等，</span><br><span class="line">                &#x2F;&#x2F; 不相等则将 sameWeight 置为 false</span><br><span class="line">                if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; firstWeight) &#123;</span><br><span class="line">                    sameWeight &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可</span><br><span class="line">        if (leastCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return invokers.get(leastIndexs[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span><br><span class="line">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 随机生成一个 [0, totalWeight) 之间的数字</span><br><span class="line">            int offsetWeight &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; 循环让随机数减去具有最小活跃数的 Invoker 的权重值，</span><br><span class="line">            &#x2F;&#x2F; 当 offset 小于等于0时，返回相应的 Invoker</span><br><span class="line">            for (int i &#x3D; 0; i &lt; leastCount; i++) &#123;</span><br><span class="line">                int leastIndex &#x3D; leastIndexs[i];</span><br><span class="line">                &#x2F;&#x2F; 获取权重值，并让随机数减去权重值 - ⭐️</span><br><span class="line">                offsetWeight -&#x3D; getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                if (offsetWeight &lt;&#x3D; 0)</span><br><span class="line">                    return invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果权重相同或权重为0时，随机返回一个 Invoker</span><br><span class="line">        return invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>遍历 invokers 列表，寻找活跃数最小的 Invoker</li><li>如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</li><li>如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</li><li>如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 RandomLoadBalance 一致</li><li>如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可</li></ol><h1 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h1><p>所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class RoundRobinLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;roundrobin&quot;;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences &#x3D; </span><br><span class="line">        new ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        &#x2F;&#x2F; key &#x3D; 全限定类名 + &quot;.&quot; + 方法名，比如 com.xxx.DemoService.sayHello</span><br><span class="line">        String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        &#x2F;&#x2F; 最大权重</span><br><span class="line">        int maxWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 最小权重</span><br><span class="line">        int minWeight &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        final LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap &#x3D; new LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class="line">        &#x2F;&#x2F; 权重总和</span><br><span class="line">        int weightSum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 下面这个循环主要用于查找最大和最小权重，计算权重总和等</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            &#x2F;&#x2F; 获取最大和最小权重</span><br><span class="line">            maxWeight &#x3D; Math.max(maxWeight, weight);</span><br><span class="line">            minWeight &#x3D; Math.min(minWeight, weight);</span><br><span class="line">            if (weight &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 将 weight 封装到 IntegerWrapper 中</span><br><span class="line">                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));</span><br><span class="line">                &#x2F;&#x2F; 累加权重</span><br><span class="line">                weightSum +&#x3D; weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 查找 key 对应的对应 AtomicPositiveInteger 实例，为空则创建。</span><br><span class="line">        &#x2F;&#x2F; 这里可以把 AtomicPositiveInteger 看成一个黑盒，大家只要知道</span><br><span class="line">        &#x2F;&#x2F; AtomicPositiveInteger 用于记录服务的调用编号即可。至于细节，</span><br><span class="line">        &#x2F;&#x2F; 大家如果感兴趣，可以自行分析</span><br><span class="line">        AtomicPositiveInteger sequence &#x3D; sequences.get(key);</span><br><span class="line">        if (sequence &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sequences.putIfAbsent(key, new AtomicPositiveInteger());</span><br><span class="line">            sequence &#x3D; sequences.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取当前的调用编号</span><br><span class="line">        int currentSequence &#x3D; sequence.getAndIncrement();</span><br><span class="line">        &#x2F;&#x2F; 如果最小权重小于最大权重，表明服务提供者之间的权重是不相等的</span><br><span class="line">        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用调用编号对权重总和进行取余操作</span><br><span class="line">            int mod &#x3D; currentSequence % weightSum;</span><br><span class="line">            &#x2F;&#x2F; 进行 maxWeight 次遍历</span><br><span class="line">            for (int i &#x3D; 0; i &lt; maxWeight; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历 invokerToWeightMap</span><br><span class="line">                for (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class="line">&#x2F;&#x2F; 获取 Invoker</span><br><span class="line">                    final Invoker&lt;T&gt; k &#x3D; each.getKey();</span><br><span class="line">                    &#x2F;&#x2F; 获取权重包装类 IntegerWrapper</span><br><span class="line">                    final IntegerWrapper v &#x3D; each.getValue();</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 如果 mod &#x3D; 0，且权重大于0，此时返回相应的 Invoker</span><br><span class="line">                    if (mod &#x3D;&#x3D; 0 &amp;&amp; v.getValue() &gt; 0) &#123;</span><br><span class="line">                        return k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; mod !&#x3D; 0，且权重大于0，此时对权重和 mod 分别进行自减操作</span><br><span class="line">                    if (v.getValue() &gt; 0) &#123;</span><br><span class="line">                        v.decrement();</span><br><span class="line">                        mod--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 服务提供者之间的权重相等，此时通过轮询选择 Invoker</span><br><span class="line">        return invokers.get(currentSequence % length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; IntegerWrapper 是一个 int 包装类，主要包含了一个自减方法。</span><br><span class="line">    private static final class IntegerWrapper &#123;</span><br><span class="line">        private int value;</span><br><span class="line"></span><br><span class="line">        public void decrement() &#123;</span><br><span class="line">            this.value--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 省略部分代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，RoundRobinLoadBalance 的每行代码都不是很难理解，但是将它们组合在一起之后，就不是很好理解了。所以下面我们举例进行说明，假设我们有三台服务器 servers = [A, B, C]，对应的权重为 weights = [2, 5, 1]。接下来对上面的逻辑进行简单的模拟。</p><p>mod = 0：满足条件，此时直接返回服务器 A</p><p>mod = 1：需要进行一次递减操作才能满足条件，此时返回服务器 B</p><p>mod = 2：需要进行两次递减操作才能满足条件，此时返回服务器 C</p><p>mod = 3：需要进行三次递减操作才能满足条件，经过递减后，服务器权重为 [1, 4, 0]，此时返回服务器 A</p><p>mod = 4：需要进行四次递减操作才能满足条件，经过递减后，服务器权重为 [0, 4, 0]，此时返回服务器 B</p><p>mod = 5：需要进行五次递减操作才能满足条件，经过递减后，服务器权重为 [0, 3, 0]，此时返回服务器 B</p><p>mod = 6：需要进行六次递减操作才能满足条件，经过递减后，服务器权重为 [0, 2, 0]，此时返回服务器 B</p><p>mod = 7：需要进行七次递减操作才能满足条件，经过递减后，服务器权重为 [0, 1, 0]，此时返回服务器 B</p><p>经过8次调用后，我们得到的负载均衡结果为 [A, B, C, A, B, B, B, B]，次数比 A:B:C = 2:5:1，等于权重比。当 sequence = 8 时，mod = 0，此时重头再来。从上面的模拟过程可以看出，当 mod &gt;= 3 后，服务器 C 就不会被选中了，因为它的权重被减为0了。当 mod &gt;= 4 后，服务器 A 的权重被减为0，此后 A 就不会再被选中。</p><p>以上是 2.6.4 版本的 RoundRobinLoadBalance 分析过程，2.6.4 版本的 RoundRobinLoadBalance 在某些情况下存在着比较严重的性能问题，该问题最初是在 issue #2578 中被反馈出来。问题出在了 Invoker 的返回时机上，RoundRobinLoadBalance 需要在mod == 0 &amp;&amp; v.getValue() &gt; 0 条件成立的情况下才会被返回相应的 Invoker。假如 mod 很大，比如 10000，50000，甚至更大时，doSelect 方法需要进行很多次计算才能将 mod 减为0。由此可知，doSelect 的效率与 mod 有关，时间复杂度为 O(mod)。mod 又受最大权重 maxWeight 的影响，因此当某个服务提供者配置了非常大的权重，此时 RoundRobinLoadBalance 会产生比较严重的性能问题。这个问题被反馈后，社区很快做了回应。并对 RoundRobinLoadBalance 的代码进行了重构，将时间复杂度优化至了常量级别。这个优化可以说很好了，下面我们来学习一下优化后的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class RoundRobinLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;roundrobin&quot;;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences &#x3D; new ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class="line"></span><br><span class="line">    private final ConcurrentMap&lt;String, AtomicPositiveInteger&gt; indexSeqs &#x3D; new ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        int maxWeight &#x3D; 0;</span><br><span class="line">        int minWeight &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        final List&lt;Invoker&lt;T&gt;&gt; invokerToWeightList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 查找最大和最小权重</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            maxWeight &#x3D; Math.max(maxWeight, weight);</span><br><span class="line">            minWeight &#x3D; Math.min(minWeight, weight);</span><br><span class="line">            if (weight &gt; 0) &#123;</span><br><span class="line">                invokerToWeightList.add(invokers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取当前服务对应的调用序列对象 AtomicPositiveInteger</span><br><span class="line">        AtomicPositiveInteger sequence &#x3D; sequences.get(key);</span><br><span class="line">        if (sequence &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建 AtomicPositiveInteger，默认值为0</span><br><span class="line">            sequences.putIfAbsent(key, new AtomicPositiveInteger());</span><br><span class="line">            sequence &#x3D; sequences.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取下标序列对象 AtomicPositiveInteger</span><br><span class="line">        AtomicPositiveInteger indexSeq &#x3D; indexSeqs.get(key);</span><br><span class="line">        if (indexSeq &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建 AtomicPositiveInteger，默认值为 -1</span><br><span class="line">            indexSeqs.putIfAbsent(key, new AtomicPositiveInteger(-1));</span><br><span class="line">            indexSeq &#x3D; indexSeqs.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class="line">            length &#x3D; invokerToWeightList.size();</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                int index &#x3D; indexSeq.incrementAndGet() % length;</span><br><span class="line">                int currentWeight &#x3D; sequence.get() % maxWeight;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 每循环一轮（index &#x3D; 0），重新计算 currentWeight</span><br><span class="line">                if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    currentWeight &#x3D; sequence.incrementAndGet() % maxWeight;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 检测 Invoker 的权重是否大于 currentWeight，大于则返回</span><br><span class="line">                if (getWeight(invokerToWeightList.get(index), invocation) &gt; currentWeight) &#123;</span><br><span class="line">                    return invokerToWeightList.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 所有 Invoker 权重相等，此时进行普通的轮询即可</span><br><span class="line">        return invokers.get(sequence.incrementAndGet() % length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是这样的，每进行一轮循环，重新计算 currentWeight。如果当前 Invoker 权重大于 currentWeight，则返回该 Invoker。下面举例说明，假设服务器 [A, B, C] 对应权重 [5, 2, 1]。</p><p>第一轮循环，currentWeight = 1，可返回 A 和 B</p><p>第二轮循环，currentWeight = 2，返回 A</p><p>第三轮循环，currentWeight = 3，返回 A</p><p>第四轮循环，currentWeight = 4，返回 A</p><p>第五轮循环，currentWeight = 0，返回 A, B, C</p><p>如上，这里的一轮循环是指 index 再次变为0所经历过的循环，这里可以把 index = 0 看做是一轮循环的开始。每一轮循环的次数与 Invoker 的数量有关，Invoker 数量通常不会太多，所以我们可以认为上面代码的时间复杂度为常数级。</p><p>重构后的 RoundRobinLoadBalance 看起来已经很不错了，但是在代码更新不久后，很快又被重构了。这次重构原因是新的 RoundRobinLoadBalance 在某些情况下选出的服务器序列不够均匀。比如，服务器 [A, B, C] 对应权重 [5, 1, 1]。进行7次负载均衡后，选择出来的序列为 [A, A, A, A, A, B, C]。前5个请求全部都落在了服务器 A上，这将会使服务器 A 短时间内接收大量的请求，压力陡增。而 B 和 C 此时无请求，处于空闲状态。而我们期望的结果是这样的 [A, A, B, A, C, A, A]，不同服务器可以穿插获取请求。为了增加负载均衡结果的平滑性，社区再次对 RoundRobinLoadBalance 的实现进行了重构，这次重构参考自 Nginx 的平滑加权轮询负载均衡。每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。</p><p>上面描述不是很好理解，下面还是举例进行说明。这里仍然使用服务器 [A, B, C] 对应权重 [5, 1, 1] 的例子说明，现在有7个请求依次进入负载均衡逻辑，选择过程如下：<br>|请求编 号 | currentWeight 数组    | 选择结果    |减去权重总和后的 currentWeight 数组 |<br>| — | —| — | — |<br>| 1 | [5, 1, 1] | A | [-2, 1, 1] |<br>| 2 | [3, 2, 2] | A | [-4, 2, 2] |<br>| 3 | [1, 3, 3] | B | [1, -4, 3] |<br>| 4 | [6, -3, 4] | A | [-1, -3, 4] |<br>| 5 | [4, -2, 5] | C | [4, -2, -2] |<br>| 6 | [9, -1, -1] | A | [2, -1, -1] |<br>| 7 | [7, 0, 0] | A | [0, 0, 0] |</p><p>如上，经过平滑性处理后，得到的服务器序列为 [A, A, B, A, C, A, A]，相比之前的序列 [A, A, A, A, A, B, C]，分布性要好一些。初始情况下 currentWeight = [0, 0, 0]，第7个请求处理完后，currentWeight 再次变为 [0, 0, 0]。</p><p>以上就是平滑加权轮询的计算过程，接下来，我们来看看 Dubbo-2.6.5 是如何实现上面的计算过程的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">public class RoundRobinLoadBalance extends AbstractLoadBalance &#123;</span><br><span class="line">    public static final String NAME &#x3D; &quot;roundrobin&quot;;</span><br><span class="line">    </span><br><span class="line">    private static int RECYCLE_PERIOD &#x3D; 60000;</span><br><span class="line">    </span><br><span class="line">    protected static class WeightedRoundRobin &#123;</span><br><span class="line">        &#x2F;&#x2F; 服务提供者权重</span><br><span class="line">        private int weight;</span><br><span class="line">        &#x2F;&#x2F; 当前权重</span><br><span class="line">        private AtomicLong current &#x3D; new AtomicLong(0);</span><br><span class="line">        &#x2F;&#x2F; 最后一次更新时间</span><br><span class="line">        private long lastUpdate;</span><br><span class="line">        </span><br><span class="line">        public void setWeight(int weight) &#123;</span><br><span class="line">            this.weight &#x3D; weight;</span><br><span class="line">            &#x2F;&#x2F; 初始情况下，current &#x3D; 0</span><br><span class="line">            current.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">        public long increaseCurrent() &#123;</span><br><span class="line">            &#x2F;&#x2F; current &#x3D; current + weight；</span><br><span class="line">            return current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        public void sel(int total) &#123;</span><br><span class="line">            &#x2F;&#x2F; current &#x3D; current - total;</span><br><span class="line">            current.addAndGet(-1 * total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 嵌套 Map 结构，存储的数据结构示例如下：</span><br><span class="line">    &#x2F;&#x2F; &#123;</span><br><span class="line">    &#x2F;&#x2F;     &quot;UserService.query&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F;         &quot;url1&quot;: WeightedRoundRobin@123, </span><br><span class="line">    &#x2F;&#x2F;         &quot;url2&quot;: WeightedRoundRobin@456, </span><br><span class="line">    &#x2F;&#x2F;     &#125;,</span><br><span class="line">    &#x2F;&#x2F;     &quot;UserService.update&quot;: &#123;</span><br><span class="line">    &#x2F;&#x2F;         &quot;url1&quot;: WeightedRoundRobin@123, </span><br><span class="line">    &#x2F;&#x2F;         &quot;url2&quot;: WeightedRoundRobin@456,</span><br><span class="line">    &#x2F;&#x2F;     &#125;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">    &#x2F;&#x2F; 最外层为服务类名 + 方法名，第二层为 url 到 WeightedRoundRobin 的映射关系。</span><br><span class="line">    &#x2F;&#x2F; 这里我们可以将 url 看成是服务提供者的 id</span><br><span class="line">    private ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap &#x3D; new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 原子更新锁</span><br><span class="line">    private AtomicBoolean updateLock &#x3D; new AtomicBoolean();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();</span><br><span class="line">        &#x2F;&#x2F; 获取 url 到 WeightedRoundRobin 映射表，如果为空，则创建一个新的</span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map &#x3D; methodWeightMap.get(key);</span><br><span class="line">        if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">            methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">            map &#x3D; methodWeightMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        long maxCurrent &#x3D; Long.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取当前时间</span><br><span class="line">        long now &#x3D; System.currentTimeMillis();</span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker &#x3D; null;</span><br><span class="line">        WeightedRoundRobin selectedWRR &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 下面这个循环主要做了这样几件事情：</span><br><span class="line">        &#x2F;&#x2F;   1. 遍历 Invoker 列表，检测当前 Invoker 是否有</span><br><span class="line">        &#x2F;&#x2F;      相应的 WeightedRoundRobin，没有则创建</span><br><span class="line">        &#x2F;&#x2F;   2. 检测 Invoker 权重是否发生了变化，若变化了，</span><br><span class="line">        &#x2F;&#x2F;      则更新 WeightedRoundRobin 的 weight 字段</span><br><span class="line">        &#x2F;&#x2F;   3. 让 current 字段加上自身权重，等价于 current +&#x3D; weight</span><br><span class="line">        &#x2F;&#x2F;   4. 设置 lastUpdate 字段，即 lastUpdate &#x3D; now</span><br><span class="line">        &#x2F;&#x2F;   5. 寻找具有最大 current 的 Invoker，以及 Invoker 对应的 WeightedRoundRobin，</span><br><span class="line">        &#x2F;&#x2F;      暂存起来，留作后用</span><br><span class="line">        &#x2F;&#x2F;   6. 计算权重总和</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            String identifyString &#x3D; invoker.getUrl().toIdentityString();</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">            int weight &#x3D; getWeight(invoker, invocation);</span><br><span class="line">            if (weight &lt; 0) &#123;</span><br><span class="line">                weight &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 检测当前 Invoker 是否有对应的 WeightedRoundRobin，没有则创建</span><br><span class="line">            if (weightedRoundRobin &#x3D;&#x3D; null) &#123;</span><br><span class="line">                weightedRoundRobin &#x3D; new WeightedRoundRobin();</span><br><span class="line">                &#x2F;&#x2F; 设置 Invoker 权重</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                &#x2F;&#x2F; 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span><br><span class="line">                map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">                weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Invoker 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span><br><span class="line">            if (weight !&#x3D; weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 让 current 加上自身权重，等价于 current +&#x3D; weight</span><br><span class="line">            long cur &#x3D; weightedRoundRobin.increaseCurrent();</span><br><span class="line">            &#x2F;&#x2F; 设置 lastUpdate，表示近期更新过</span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            &#x2F;&#x2F; 找出最大的 current </span><br><span class="line">            if (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent &#x3D; cur;</span><br><span class="line">                &#x2F;&#x2F; 将具有最大 current 权重的 Invoker 赋值给 selectedInvoker</span><br><span class="line">                selectedInvoker &#x3D; invoker;</span><br><span class="line">                &#x2F;&#x2F; 将 Invoker 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span><br><span class="line">                selectedWRR &#x3D; weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 计算权重总和</span><br><span class="line">            totalWeight +&#x3D; weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对 &lt;identifyString, WeightedRoundRobin&gt; 进行检查，过滤掉长时间未被更新的节点。</span><br><span class="line">        &#x2F;&#x2F; 该节点可能挂了，invokers 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span><br><span class="line">        &#x2F;&#x2F; 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span><br><span class="line">        if (!updateLock.get() &amp;&amp; invokers.size() !&#x3D; map.size()) &#123;</span><br><span class="line">            if (updateLock.compareAndSet(false, true)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap &#x3D; new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                    &#x2F;&#x2F; 拷贝</span><br><span class="line">                    newMap.putAll(map);</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 遍历修改，即移除过期记录</span><br><span class="line">                    Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it &#x3D; newMap.entrySet().iterator();</span><br><span class="line">                    while (it.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;String, WeightedRoundRobin&gt; item &#x3D; it.next();</span><br><span class="line">                        if (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 更新引用</span><br><span class="line">                    methodWeightMap.put(key, newMap);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    updateLock.set(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (selectedInvoker !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 让 current 减去权重总和，等价于 current -&#x3D; totalWeight</span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; 返回具有最大 current 的 Invoker</span><br><span class="line">            return selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; should not happen here</span><br><span class="line">        return invokers.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="2019/12/17/develop/zookeeper/"/>
      <url>2019/12/17/develop/zookeeper/</url>
      
        <content type="html"><![CDATA[<p>zookeeper是一个分布式，开源的分布式应用协调服务。它提供了一系列简单的基元，分布式程序可以在此基础上组建更高级别的同步服务，配置维护，组及命名。其设计成易于编写并且按照文件系统树型结构的数据模型。</p><span id="more"></span><h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>zookeeper 允许分布式进程通过共享的层次命名空间去互相协调，类似标准的文件系统。命名空间由数据寄存器构成-znodes，在zookeeper语境中，这些与文件，文件目录类似。不同于文件系统基于存储的目的，zookeeper的数据保留在内存中，这是zookeeper高吞吐率及低延迟的保证。</p><h2 id="可复制的"><a href="#可复制的" class="headerlink" title="可复制的"></a>可复制的</h2><p>zookeeper的实现保证了高性能，高可用及严格的访问顺序。在性能方面可以用于大型的分布式系统。可靠性方面也不会出现单点失败，严格的顺序意味着复杂的同步组件可以在客户端中实现。</p><p><img src="/images/zookeeper/zkservice.jpg" alt=""></p><p>zookeeper维持着一个内存状态镜像，以及持久化的事务日志及快照。只要大多数的服务是可用的，zookeeper服务就是可用的。客户端连到一个单点的zookeeper服务，并维持着一个长连接，通过这个长连接发送请求，得到响应，监听事件及发送心跳包，如果这个服务宕机，客户端会连到一个不通的服务。</p><h2 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h2><p>zookeeper用一个数字来标记每个更新，这个数字对应着事务的顺序，随后的操作可以用这个顺序来实现更高级别的抽象逻辑，例如同步组件。</p><h2 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h2><p>本质上是已读为主，所以速度很快，zookeeper程序运行在数千台机器上，以读为主的性能会更好，这个比例在10:1左右。</p><h1 id="数据模型及层次命名空间"><a href="#数据模型及层次命名空间" class="headerlink" title="数据模型及层次命名空间"></a>数据模型及层次命名空间</h1><p>zookeeper的命名空间类似标准的文件系统，每一个节点都有一个路径标识。<br><img src="/images/zookeeper/zknamespace.jpg" alt=""></p><h1 id="节点及临时节点"><a href="#节点及临时节点" class="headerlink" title="节点及临时节点"></a>节点及临时节点</h1><p>每一个节点都可以关联着数据及子节点，就像是文件系统中可以是文件也可以是文件夹，(zookeeper用于储存协调数据：状态信息，配置，位置信息等等，所以每个节点的数据非常小），我们用znode来表示这些节点。</p><p>znode维持着一个统计结构包含数据修改的版本号，acl改变，时间戳，允许缓存的验证及协调更新。每一次数据的改变，版本号会递增，例如当一个客户端检索数据也会收到数据的版本号。在命名空间中的znode数据是自动读写的，读取会得到所有于这个节点关联的数据，而写会替换所有的数据。每一个节点有一份acl，可以严格的控制谁可以访问。</p><p>zookeeper还有临时节点的概念，这些节点跟随着一个会话的生命周期，当会话结束后这些节点也会被删除</p><h1 id="条件更新及监听"><a href="#条件更新及监听" class="headerlink" title="条件更新及监听"></a>条件更新及监听</h1><p>zookeeper支持监听，客户端可以在节点上创建监听，当一个节点改变时监听器会触发和删除。当一个节点发生改变，客户端会收到包，如果客户端与zookeeper服务器间的长连接断开，客户端会收到一个本地的通知事件。</p><h1 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h1><p> zookeeper非常快速简单，基于其设计的目的，它可以作为其他更复杂服务的一个组件，例如同步，它提供了一套保证：</p><ul><li>顺序一致性，所有的更新操作跟从客户端的发过来的顺序一致</li><li>原子性</li><li>单一系统镜像，不管客户端连的是哪个服务，其得到的数据都是一致</li><li>可靠性，一旦更新成功，这个数据会一致保存着直到被覆盖</li><li>实时性，在一定的时间范围内，客户端的视图都是最新的</li></ul><h1 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h1><p> zookeeper提供的接口非常简单，支持如下操作：</p><ul><li><code>create</code>: 在树的指定位置创建一个节点</li><li><code>delete</code>: 删除一个节点</li><li><code>exists</code>: 检查一个节点是否存在</li><li><code>get data</code>: 读取</li><li><code>send data</code>: 发送</li><li><code>get children</code>: 获取当前节点下的所有子节点 </li><li><code>sync</code>: 等待数据被同步完毕</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/images/zookeeper/zkcomponents.jpg" alt=""></p><p>除了请求处理器外，每一个服务都由其复制自身的副本构成。这些副本的数据库是在内存中维持整个树结构，更新操作会固化到磁盘中以供后续恢复，写操作在应用到内存前会先序列化到磁盘中。</p><p>客户端连接到一个确定的服务器去提交请求，从每个服务的副本中读取数据，由一致性协议去处理服务的更新状态。作为一致性协议的一部分，所有从客户端的过来的请求都被重定向到同一个节点(leader)。剩下的这些服务叫做followes，从leader中收到提案消息，并对消息传递达成一致。</p><p>ZooKeeper使用自定义原子消息传递协议。因为消息层是原子的，所以ZooKeeper可以保证本地副本不会发散。当leader收到一个写请求时，它会计算将要应用的写时系统的状态，并将其转换为捕获这个新状态的事务</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ZAB</title>
      <link href="2019/12/16/develop/zab/"/>
      <url>2019/12/16/develop/zab/</url>
      
        <content type="html"><![CDATA[<p>zab是zookeeper用来传播状态更新的广播协议，其类似于paxos协议，与paxos不同的是zab可以恢复历史记录，而不是单个协议实例。Zab具有前缀排序属性，允许主/备份实现一次有多个未完成的操作;Zab在leader变更时进行特殊处理，以保证领导者提出的值具有唯一的序列号。</p><span id="more"></span><p>客户端与服务端的初始握手结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LearnerInfo &#123;</span><br><span class="line">    int protocolVersion;</span><br><span class="line">    int serverid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>leader与follower之前的使用单一的数据结构来进行提案的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class QuorumPacket &#123;</span><br><span class="line">    int type; &#x2F;&#x2F; Request, Ack, Commit, Ping, etc</span><br><span class="line">    long zxid;</span><br><span class="line">    buffer data;</span><br><span class="line">    vector&lt;org.apache.zookeeper.data.Id&gt; authinfo; &#x2F;&#x2F;only used for requests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>type</th><th>zxid</th><th>data</th><th>notation</th><th>meaning</th></tr></thead><tbody><tr><td>FOLLOWERINFO(11)</td><td>acceptedEpoch</td><td>LearnerInfo</td><td>FOLLOWERINFO(acceptedEpoch)</td><td>跟随者已经收到了多少个纪元</td></tr><tr><td>NEWLEADER(10)</td><td>e &lt;&lt; 32</td><td>n/a</td><td>NEWLEADER(e)</td><td>在e纪元时接受新的leader</td></tr><tr><td>DIFF(13)</td><td>last committed zxid</td><td>n/a</td><td>DIFF(lastCommittedZxid)</td><td>上一次leader提交的zxid</td></tr><tr><td>OBSERVERINFO(16)</td><td>last zxid learned</td><td>LearnerInfo</td><td>OBSERVERINFO(lastZxid)</td><td>观察者接受到lastZxid。</td></tr><tr><td>SNAP(15)</td><td>lastZxid</td><td>n/a</td><td>SNAP</td><td>状态传送(即快照)将发送给跟随者。这将是一个模糊状态转移，可能包括发送给跟随者的zxid。状态传输将立即跟随这个包。</td></tr><tr><td>ACKEPOCH(18)</td><td>lastZxid</td><td>currentEpoch</td><td>ACKEPOCH(lastZxid, currentEpoch)</td><td>承认对新纪元的接受。如果跟随者已经确认了给定的纪元，那么它将传递-1作为当前时值，以表示没有确认新的纪元。(如果需要同步，我们仍然需要发送lastZxid)</td></tr><tr><td>UPTODATE(12)</td><td>n/a</td><td>n/a</td><td>UPTODATE</td><td>跟随者当前时最新的状态，可以对外服务</td></tr><tr><td>LEADERINFO(18)</td><td>proposed epoch</td><td>protocol</td><td>LEADERINFO(e)</td><td>新的提案纪元</td></tr><tr><td>TRUNC(14)</td><td>truncZxid</td><td>n/a</td><td>TRUNC(truncZxid)</td><td>将历史截取为 truncZxid</td></tr><tr><td>PROPOSAL(2)</td><td>zxid of proposal</td><td>proposed message</td><td>PROPOSAL(zxid, data)</td><td>提出一个消息(请求它被一个跟随者的历史所接受。)</td></tr><tr><td>INFORM(8)</td><td>zxid of proposal</td><td>data of proposal</td><td>INFORM(zxid, data)</td><td>传送数据，仅仅在观察者中使用</td></tr><tr><td>ACK(3)</td><td>zxid of proposal to ack</td><td>n/a</td><td>ACK(zxid)</td><td>所有从leader发送到跟随者的zxid的数据都会被接受(日志写入到磁盘)</td></tr><tr><td>COMMIT(4)</td><td>zxid of proposal to commit</td><td>n/a</td><td>COMMIT(zxid)</td><td>跟随者中所有zxid的信息都应该被提交</td></tr></tbody></table><h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>所有的服务都从leader选举开始，一旦给定服务器上leader选举指明了新的leader，将进行第一阶段。如果选举过程中当前实例就是leader，当前作为leader进行第一阶段，否则作为follower进行第一阶段。</p><h1 id="阶段1：创建新的纪元"><a href="#阶段1：创建新的纪元" class="headerlink" title="阶段1：创建新的纪元"></a>阶段1：创建新的纪元</h1><p>在这个阶段leader要确保之前的leader不能提交新的提议，并且决定初始的历史。(注意，一个leader也可以作为自己的follower)，任何错误或者超时服务都会回到选举过程</p><ol><li>leader开始接受follower的连接</li><li>followers连接到leader,并发送<code>FOLLOWERINFO</code>.</li><li>一旦leader得到大多数的信息，停止连接，并发送LEADERINFO(e)给followers</li><li>当follower收到LEADERINFO(e)<ul><li>如果 <code>e &gt; f.acceptedEpoch</code>,设置 f.acceptedEpoch，并发送 ACKEPOCH(e);</li><li>如果 <code>e == f.accepetdEpoch</code>，不会发送ACKEPOCH,但会继续下一步骤</li><li>如果 <code>e &lt; f.accepetdEpoch</code>，follower会断开连接，并回到leader选举</li></ul></li><li>如果leader等待大多数的follower发送的 ACKEPOCH</li><li>如果所有连接着的跟随者不满足以下条件，leader会断开与followers的连接，并回到选举阶段<ul><li>f.currentEpoch &lt;= l.currentEpoch</li><li>if f.currentEpoch == l.currentEpoch,then f.lastZxid &lt;= l.lastZxid </li></ul></li></ol><p>注意，如果一个follower正在连接，但是leader已经建立(在阶段3)，follower遵循阶段，但是leader忽略任何ack。</p><p>我们使用最新的leader选举协议保证leader是大多数进程最新的历史记录，同时也保证只有一个leader被选举除。不过由于条件竞争，过时的信息，更有甚者实现错误导致这个保证出错，所以要确保满足第一阶段。</p><h1 id="阶段2：同步followers"><a href="#阶段2：同步followers" class="headerlink" title="阶段2：同步followers"></a>阶段2：同步followers</h1><ol><li>leader对每个连接的follower做如下操作：<ul><li>添加到连接表中并发送新的提议，因此当服务器执行下一步时，发送给follower的提议会按照队列发送</li><li>如果follower是如下情况<ul><li>SNAP，如果当前follower远远落后于SNAP，此时状态转移比发送丢失的事务要好</li><li>TRUNC(zxid)，如果follower有事务被leader跳过，leader设置last zxid作为follower当前纪元的最新历史，然后leader 发送follower丢失的事务</li><li>DIFF,如果leader发送的事务而follower已经丢失，leader发送丢失的消息给follower</li></ul></li><li>发送 NEWLEADER(e)</li><li>leader释放所有给follower的队列消息</li></ul></li><li>follower与leader同步，但是直到收到NEWLEADER(e)数据包才会修改状态。一旦它接收到NEWLEADER(e)，它就自动应用新的状态并设置f。然后发送ACK(e &lt;&lt; 32)  </li><li>一旦leader收到一个法定人数的follower的ack，它将接管新纪元e的领导权，并向所有的follower更新队列。</li><li>当一个follower收到更新消息时，它开始接受客户端连接并为新状态提供服务。</li><li>leader再次开始接受follower的联系。变量nextZxid被设置为(e &lt;&lt; 32) + 1。进入翻译页面  </li></ol><h1 id="阶段3：广播"><a href="#阶段3：广播" class="headerlink" title="阶段3：广播"></a>阶段3：广播</h1><p>leader和follower可以在过程中以及在管道的不同阶段有多个建议。只要在超时间隔内有足够数量的follower确认其建议或ping信号，leader将保持活动状态。follower将继续支持leader，只要它在超时间隔内收到提议或ping信号。任何故障或超时将导致服务器返回到选举过程</p><ul><li>leader将一个包的提议(zxid, data)排队，其中zxid = nextZxid，发送给所有连接的follower。增量nextZxid。</li><li>一个follower将记录和同步建议到磁盘和发送ACK(zxid)。</li><li>当leader收到一个follower法定人数的确认信息时，它将队列提交(zxid)给所有的follower</li></ul><h1 id="zab与paxos的区别"><a href="#zab与paxos的区别" class="headerlink" title="zab与paxos的区别"></a>zab与paxos的区别</h1><p>Zab是一个不同于Paxos的协议，虽然它与Paxos有一些关键的共同点，例如:</p><ul><li>领导者向追随者发提案</li><li>领导者在考虑一个已提交的提议之前，要等待多数追随者的确认。</li><li>提案包括大纪元号码，类似于Paxos中的选票号码</li></ul><p>Zab和Paxos之间的主要概念区别在于，它主要是为像Zookeeper这样的主备份系统设计的，而不是为状态机复制设计的。</p><h2 id="主备份和状态机复制之间的区别"><a href="#主备份和状态机复制之间的区别" class="headerlink" title="主备份和状态机复制之间的区别"></a>主备份和状态机复制之间的区别</h2><p>状态机是处理一系列请求的软件组件。对于每个已处理的请求，它可以修改其内部状态并产生答复。状态机在某种意义上是确定性的，即在给定两次运行时，如果它接收到相同的请求序列，则它始终会进行相同的内部状态转换并产生相同的答复。</p><p>状态机复制系统是一个客户端服务器系统，即使每个请求由客户端同时提交并由副本以不同顺序接收，也可以确保每个状态机副本执行相同的客户端请求序列。副本使用诸如Paxos之类的共识算法就客户端请求的执行顺序达成一致。同时发送并在时间上重叠的客户端请求可以按任何顺序执行。如果领导者失败，则执行恢复的新领导者可以随意重新排序任何未提交的请求，因为该请求尚未完成。</p><p>对于主备份系统（例如Zookeeper），副本在增量（增量）状态更新的应用程序顺序上达成一致，增量状态更新由主副本生成并发送给其跟随者。与客户端请求不同，状态更新必须从主数据库的原始初始状态开始，按照主数据库的原始原始生成顺序进行应用。如果主服务器发生故障，则执行恢复的新主服务器无法任意重新排序未提交的状态更新，也不能从其他初始状态开始应用它们。</p><p>总之，与对客户端请求的协议（对于状态机复制系统）相比，对状态更新的协议（对于主备份系统）需要更严格的顺序保证。</p><h2 id="协议算法的含义"><a href="#协议算法的含义" class="headerlink" title="协议算法的含义"></a>协议算法的含义</h2><p>通过让主服务器成为领导者，Paxos可以用于主数据库备份复制。 Paxos的问题在于，如果主数据库同时提出多个状态更新而失败，则新的主数据库可能会以不正确的顺序应用未提交的更新。我们的DSN 2011论文中提供了一个示例（图1）。在该示例中，副本应仅在应用A之后应用状态更新B。该示例显示，使用Paxos，新的主数据库及其跟随对象可以在C之后应用B，从而达到任何状态都未达到的不正确状态以前的初选。</p><p>使用Paxos解决此问题的一种方法是依次同意状态更新：主要数据库仅在提交所有先前的状态更新后才提出状态更新。由于一次最多有一个未提交的更新，因此新的主数据库不能错误地对更新进行重新排序。但是，这种方法会导致性能下降。</p><p>Zab不需要此解决方法。 Zab副本可以并发地同意多个状态更新的顺序，而不会损害正确性。与Paxos相比，在恢复过程中增加了一个同步阶段，并通过使用基于zxid的不同编号的实例来实现这一点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flink分布式运行环境</title>
      <link href="2019/12/11/develop/flink%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>2019/12/11/develop/flink%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="任务和操作链"><a href="#任务和操作链" class="headerlink" title="任务和操作链"></a>任务和操作链</h1><p>对于分布式执行，将操作符子任务一起链接到任务中。每个任务由一个线程执行。将操作符链接到任务中是一个有用的优化:它减少了线程到线程切换和缓冲的开销，增加了总体吞吐量，同时降低了延迟。可以配置链接行为。</p><p>下图中的示例数据流使用5个子任务执行，因此使用5个并行线程。</p><span id="more"></span><p><img src="/images/flink/tasks_chains.svg" alt=""></p><h1 id="作业管理器-任务管理器-客户端"><a href="#作业管理器-任务管理器-客户端" class="headerlink" title="作业管理器, 任务管理器, 客户端"></a>作业管理器, 任务管理器, 客户端</h1><p>Flink运行时由两类进程组成:</p><ul><li>作业管理器主要用于协调分布式执行。安排任务，协调检查点，协调错误恢复等。至少有一个作业管理器，一个高可用架构至少有多个作业管理器。其中一个是领导者，其他是跟随者。</li><li>任务管理器主要执行数据流任务，缓存和交换数据流，至少需要一个任务管理器</li></ul><p>作业管理器和任务管理器可以已多种方式启动。直接在机器上已独立的集群，容器，或者由资源管理框架管理，如YARN,Mesos。任务管理器连接到作业管理器，声明自身可用，然后被赋予任务。</p><p>客户端不是运行时和程序执行的一部分，而是用于准备和向JobManager发送数据流。之后，客户端可以断开连接，或保持连接以接收进度报告。客户机可以作为触发执行的Java/Scala程序的一部分运行，也可以在命令行进程中运行。<code>./bin/flink run ....</code></p><p><img src="/images/flink/processes.svg" alt=""></p><h1 id="任务槽和资源"><a href="#任务槽和资源" class="headerlink" title="任务槽和资源"></a>任务槽和资源</h1><p>每个worker (TaskManager)是一个JVM进程，可以在单独的线程中执行一个或多个子任务。为了控制一个worker接受多少任务，一个worker有所谓的任务插槽(至少一个)。每个任务槽表示TaskManager资源的一个固定子集。例如，一个有三个插槽的TaskManager会为每个插槽分配1/3的托管内存。分配资源意味着子任务不会与来自其他作业的子任务争夺托管内存，而是保留一定数量的托管内存。注意，这里没有CPU隔离;当前插槽只分隔任务的托管内存。通过调整任务槽的数量，用户可以定义子任务如何彼此隔离。每个TaskManager有一个槽意味着每个任务组在单独的JVM中运行(例如，可以在单独的容器中启动)。拥有多个插槽意味着更多的子任务共享相同的JVM。同一JVM中的任务共享TCP连接(通过多路复用)和心跳消息。它们还可以共享数据集和数据结构，从而减少每个任务的开销。</p><p><img src="/images/flink/tasks_slots.svg" alt=""></p><p>默认情况下，Flink允许子任务共享插槽，即使它们是不同任务的子任务，只要它们来自相同的作业。结果是一个槽可以容纳作业的整个管道。允许这个槽共享有两个主要好处:</p><ul><li>Flink集群需要与作业中使用的最高并行度相同的任务槽。不需要计算一个程序总共包含多少任务(具有不同的并行度)。</li><li>更容易获得更好的资源利用。如果没有插槽共享，非密集型source/map()子任务将阻塞与资源密集型窗口子任务一样多的资源。使用插槽共享，将我们示例中的基础并行度从2提高到6，可以充分利用插槽资源，同时确保繁重的子任务在taskmanager中得到公平分配。</li></ul><p><img src="/images/flink/slot_sharing.svg" alt=""></p><h1 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h1><p>存储键/值索引的确切数据结构取决于所选的状态后端。一个状态后端在内存散列映射中存储数据，另一个状态后端使用RocksDB作为键/值存储。除了定义保存状态的数据结构之外，状态后端还实现了获取键/值状态的时间点快照的逻辑，并将该快照存储为检查点的一部分。</p><p><img src="/images/flink/checkpoints.svg" alt=""></p><h1 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h1><p>在数据流API中编写的程序可以从保存点恢复执行。保存点允许在不丢失任何状态的情况下更新程序和Flink集群。</p><p>保存点是手动触发的检查点，它获取程序的快照并将其写入状态后端。它们依赖于常规的检查点机制。在执行过程中，程序定期在工作节点上快照并生成检查点。对于恢复，只需要最后一个完成的检查点，而旧的检查点可以在新检查点完成后立即安全地丢弃。</p><p>保存点类似于这些定期检查点，只是它们是由用户触发的，并且在新检查点完成时不会自动过期。可以从命令行或通过REST API取消作业时创建保存点。</p>]]></content>
      
      
      <categories>
          
          <category> 实时计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink数据流编程模型</title>
      <link href="2019/12/11/develop/flink%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2019/12/11/develop/flink%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象层次"><a href="#抽象层次" class="headerlink" title="抽象层次"></a>抽象层次</h1><p>flink 提供不同的抽象层开发流式，批量应用。<br><img src="/images/flink/levels_of_abstraction.svg" alt=""></p><span id="more"></span><ul><li>最低层次的抽象仅仅提供了有状态的流。它通过流程函数嵌入到DataStream API中。它允许用户自由处理来自一个或多个流的事件，并使用一致的容错状态。此外，用户可以注册事件时间和处理时间回调，允许程序实现复杂的计算。</li><li><p>实际上，大多数应用程序不需要上面描述的底层抽象，而是根据核心API (DataStream API(有界/无界流)和DataSet API(有界数据集)进行编程。这些连贯api为数据处理提供了常见的构建块，比如用户指定的各种形式的转换、连接、聚合、窗口、状态等。在这些api中处理的数据类型用各自的编程语言表示为类。</p><p>  低层流程功能与DataStream API集成，使得仅对某些操作进行低层抽象成为可能。DataSet API在有界数据集上提供了额外的原语，比如循环/迭代。</p></li><li><p>Table API是一个以表为中心的声明性DSL，可以动态地更改表(在表示流时)。Table API遵循(扩展的)关系模型:表有一个附加的模式(类似于关系数据库中的表)，而API提供了类似的操作，如select、project、join、group-by、aggregate等。表API程序声明性地定义应该执行什么逻辑操作，而不是确切地指定操作代码的外观。虽然表API可以通过各种类型的用户定义函数进行扩展，但是它的表达能力不如核心API，但是使用起来更简洁(需要编写的代码更少)。此外，表API程序还需要经过一个在执行之前应用优化规则的优化器。</p><p>  可以在表和DataStream/DataSet之间进行无缝转换，允许程序混合表API和DataStream和DataSet API。</p></li><li>Flink提供的最高抽象级别是SQL。这种抽象在语义和表达方面与表API类似，但将程序表示为SQL查询表达式。SQL抽象与表API密切交互，SQL查询可以在表API中定义的表上执行。</li></ul><h1 id="程序与数据流"><a href="#程序与数据流" class="headerlink" title="程序与数据流"></a>程序与数据流</h1><p>Flink程序的基本构建块是流和转换。(注意的是，在Flink的DataSet API中使用的数据集也是内部流的——稍后详细介绍)。从概念上讲，流是数据记录的流(可能永远不会结束)，转换是将一个或多个流作为输入，并产生一个或多个输出流的操作。</p><p>当执行时，Flink程序被映射到流数据流，由流和转换操作符组成。每个数据流开始于一个或多个源，结束于一个或多个汇聚。数据流类似于任意有向无环图(DAGs)。虽然通过迭代构造可以允许特殊形式的循环，但为了简单起见，我们在大多数情况下会忽略这一点。</p><p><img src="/images/flink/program_dataflow.svg" alt=""></p><p>通常，程序中的转换与数据流中的操作符之间存在一对一的对应关系。然而，有时一个转换可能包含多个转换操作符。<br>输入和输出被记录在流连接器和批连接器文档中。转换记录在DataStream操作符和数据集转换中。</p><h1 id="并行数据流"><a href="#并行数据流" class="headerlink" title="并行数据流"></a>并行数据流</h1><p>Flink中的程序本质上是并行和分布式的。在执行期间，一个流有一个或多个流分区，每个操作符有一个或多个操作符子任务。操作符子任务彼此独立，并在不同的线程中执行，也可能在不同的机器或容器中执行。</p><p>运算符子任务的数量是特定运算符的并行度。流的并行度总是其产生算子的并行度。同一程序的不同操作符可能具有不同的并行度。</p><p><img src="/images/flink/parallel_dataflow.svg" alt=""></p><p>Streams可以在两个操作符之间以一对一(或转发)模式传输数据，也可以采用重新分布模式:</p><ul><li>一对一的流(例如上图中的源和map()操作符)保留了元素的划分和排序。这意味着map()操作符的子任务[1]将看到与源操作符的子任务[1]生成的元素顺序相同的元素。</li><li>重新分布流(如上面的map()和keyBy/window之间，以及keyBy/window和Sink之间)会改变流的分区。根据所选的转换，每个操作符子任务将数据发送到不同的目标子任务。例如keyBy()(通过散列键重新分区)、broadcast()或()(随机重新分区)。在重新分布的交换中，元素之间的顺序只在发送和接收子任务的每对中保持(例如map()的子任务[1]和keyBy/window的子任务[2])。因此，在本例中，保留了每个键的顺序，但是并行性确实引入了关于不同键的聚合结果到达接收器的顺序的不确定性。</li></ul><h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p>聚合事件(例如计数、和)在流上的工作方式与在批处理中不同。例如，不可能计算流中的所有元素，因为流通常是无限的(无界的)。相反，流上的聚合(计数、和等)是由窗口限定范围的，如“最后5分钟的计数”或“最后100个元素的总和”。</p><p>Windows可以是时间驱动的(例如:每30秒)或数据驱动的(例如:每100个元素)。人们通常会区分不同类型的窗口，比如翻滚窗口(没有重叠)、滑动窗口(有重叠)和会话窗口(被不活动的间隙打断)。</p><p><img src="/images/flink/windows.svg" alt=""></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>当提到时间在一个流程序(例如定义窗口)，可以指不同的时间概念:</p><ul><li>事件时间是创建事件的时间。它通常由事件中的时间戳来描述，例如由生产传感器或生产服务附加的时间戳。Flink通过时间戳分配程序访问事件时间戳。</li><li>摄取时间是事件在源操作符处进入Flink数据流的时间。</li><li>处理时间是每个执行基于时间的操作的操作符的本地时间。</li></ul><p><img src="/images/flink/event_ingestion_processing_time.svg" alt=""></p><h1 id="有状态的操作"><a href="#有状态的操作" class="headerlink" title="有状态的操作"></a>有状态的操作</h1><p>虽然数据流中的许多操作一次只查看单个事件(例如事件解析器)，但有些操作可以跨多个事件记住信息(例如窗口操作符)。这些操作称为有状态的。</p><p>有状态操作的状态被维护在一个可以被认为是嵌入式键/值存储的地方。状态与有状态操作符读取的流一起严格地分区和分布。因此，只有在keyBy()函数之后才能访问键/值状态，并且只能访问与当前事件的键相关的值。将流的键和状态对齐，可以确保所有状态更新都是本地操作，从而保证一致性而不增加事务开销。这种对齐还允许Flink重新分配状态并透明地调整流分区。</p><p><img src="/images/flink/state_partitioning.svg" alt=""></p><h1 id="容错检查点"><a href="#容错检查点" class="headerlink" title="容错检查点"></a>容错检查点</h1><p>Flink使用流回放和检查点的组合实现容错。检查点与每个输入流中的特定点以及每个操作符的对应状态相关。流数据流可以从检查点恢复，同时通过恢复操作符的状态并从检查点重播事件来保持一致性(一次处理语义)。</p><p>检查点间隔是一种用恢复时间(需要重播的事件数量)来平衡执行期间的容错开销的方法。</p><h1 id="批量流"><a href="#批量流" class="headerlink" title="批量流"></a>批量流</h1><p>Flink作为流程序的特殊情况执行批处理程序，其中流是有界的(元素的有限数量)。数据集在内部被视为数据流。因此，上述概念适用于批处理程序，就像它们适用于流媒体程序一样，只有少数例外:</p><ul><li>批处理程序的奥尔特容错不使用检查点。恢复是通过完全重放流来实现的。这是可能的，因为输入是有界的。这将使成本更接近于恢复，但使常规处理更便宜，因为它避免了检查点。</li><li>DataSet API中的有状态操作使用简化的内存/核外数据结构，而不是键/值索引。</li><li>DataSet API引入了特殊的同步(基于超步)迭代，这只可能在有界的流上实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实时计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink使用场景</title>
      <link href="2019/12/11/develop/flink%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>2019/12/11/develop/flink%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Apache Flink是开发和运行许多不同类型应用程序的最佳选择，因为它具有广泛的特性。flink的特性包括支持流式及批量处理，复杂的状态管理，时间事件处理语义，并且保证了只执行一次的一致性状态。此外，flink可以在多种机器环境下运行，如<code>YARN</code>,<code>apache mesos</code>,<code>k8s</code>等等，也可以在独立的物理机器上。flnik具有高可用性，没有单点故障，已经证实可以扩展到千核，tb级的应用，提供了高吞吐，低延迟的特性。<br>以下几种是flink支持的最通用的应用类型：</p><ul><li>事件驱动类型的应用</li><li>数据分析类的应用</li><li>数据管道类的应用</li></ul><span id="more"></span><h1 id="事件驱动应用"><a href="#事件驱动应用" class="headerlink" title="事件驱动应用"></a>事件驱动应用</h1><p>事件驱动应用是一个有状态的应用，从一个或多个数据流中提取到事件，并通过触发计算，状态更新或者外部的操作来响应事件。</p><p>事件驱动应用是计算层与数据层分离的传统应用程序的发展，在这个架构下，程序读取数据并将数据持久化到远程事务数据库，如mysql,mongo。</p><p>相反，事件驱动的应用程序基于有状态的流处理应用程序。在这种设计中，数据和计算是共存的，从而产生本地(内存或磁盘)数据访问。通过定期将检查点写入远程持久存储来实现容错。下图描述了传统应用程序体系结构和事件驱动应用程序之间的区别</p><p><img src="/images/flink/usecases-eventdrivenapps.png" alt=""><br>事件驱动应用程序的优点是什么?</p><p>事件驱动的应用程序不查询远程数据库，而是在本地访问它们的数据，从而在吞吐量和延迟方面获得更好的性能。远程持久存储的定期检查点可以异步地、增量地完成。因此，检查点对常规事件处理的影响非常小。然而，事件驱动的应用程序设计提供了比本地数据访问更多的好处。在分层体系结构中，多个应用程序共享同一个数据库是很常见的。因此，需要协调数据库的任何更改，例如由于应用程序更新或扩展服务而更改数据布局。由于每个事件驱动的应用程序都负责自己的数据，因此更改数据表示或扩展应用程序所需的协调较少。</p><p>Flink如何支持事件驱动的应用程序?</p><p>事件驱动应用程序的限制由流处理器处理时间和状态的能力来定义。Flink的许多突出特性都围绕这些概念。Flink提供了一组丰富的状态基元，这些基元可以管理非常大的数据量(最大可达几tb)，并且具有严格的一次一致性保证。此外，Flink支持事件时间、高度可定制的窗口逻辑以及ProcessFunction提供的细粒度时间控制，这使得高级业务逻辑的实现成为可能。此外，Flink还有一个用于复杂事件处理(CEP)的库，用于检测数据流中的模式。</p><p>然而，对于事件驱动的应用程序，Flink的突出特性是保存点。保存点是一个一致的状态图，可以用作兼容应用程序的起点。给定一个保存点，应用程序可以更新或调整其规模，或者可以启动应用程序的多个版本进行A/B测试。</p><p>以下几种是典型的事件驱动应用</p><ul><li>欺诈检测</li><li>异常检测</li><li>基于规则的提醒</li><li>业务处理监控</li><li>web应用(社交类应用)</li></ul><h1 id="数据分析应用"><a href="#数据分析应用" class="headerlink" title="数据分析应用"></a>数据分析应用</h1><p>分析性工作从原始数据中提取信息和洞察力。传统上，分析是作为对记录事件的有限数据集的批查询或应用程序执行的。为了将最新的数据合并到分析结果中，必须将其添加到分析的数据集中，然后重新运行查询或应用程序。结果被写入存储系统或作为报告发出。</p><p>有了复杂的流处理引擎，分析也可以实时执行。流查询或应用程序不是读取有限的数据集，而是吸收实时事件流，并在使用事件时不断生成和更新结果。结果要么被写入外部数据库，要么作为内部状态进行维护。指示板应用程序可以从外部数据库读取最新的结果，或者直接查询应用程序的内部状态。Flink支持流和批处理分析应用程序，如下图所示<br><img src="/images/flink/usecases-analytics.png" alt=""></p><p>流式分析应用程序的优势是什么？</p><p>与批处理分析相比，连续流分析的优势不仅有更低的延迟，同时它消除了周期性导入和查询执行。与批量查询相比，流查询不需要处理输入数据中的人工边界，这些边界是由周期性导入和输入的有界性造成的。</p><p>另一个方面是更简单的应用程序体系结构。批处理分析管道由几个独立组件组成，用于定期调度数据摄入和查询执行。可靠地操作这样的管道不是件小事，因为一个组件的故障会影响管道的以下步骤。相比之下，流分析应用程序运行在复杂的流处理器(如Flink)上，它整合了从数据摄取到连续结果计算的所有步骤。因此，它可以依靠引擎的故障恢复机制。</p><p>Flink如何支持数据分析应用程序?</p><p>Flink为连续流和批处理分析提供了非常好的支持。具体来说，它提供了一个符合ansi的SQL接口，具有用于批处理和流查询的统一语义。无论SQL查询是在记录事件的静态数据集上运行，还是在实时事件流上运行，它们都计算相同的结果。对用户定义函数的丰富支持确保可以在SQL查询中执行定制代码。如果需要更多的自定义逻辑，则Flink的DataStream API或DataSet API提供更多的低级控制。此外，Flink s Gelly库为批量数据集的大规模和高性能图分析提供了算法和构建块。</p><p>以下几种是典型的数据分析应用</p><ul><li>网络质量监控</li><li>产品更新分析</li><li>大规模的图形分析</li></ul><h1 id="数据管道应用"><a href="#数据管道应用" class="headerlink" title="数据管道应用"></a>数据管道应用</h1><p>数据仓库技术(Extract-transform-load, ETL)是在存储系统之间转换和移动数据的常用方法。通常定期触发ETL作业将数据从事务性数据库系统复制到分析数据库或数据仓库。</p><p>数据管道的作用与ETL作业类似。它们转换和丰富数据，并可以将数据从一个存储系统移动到另一个存储系统。然而，它们以连续流模式运行，而不是周期性地触发。因此，它们能够从不断产生数据的源读取记录，并以低延迟将其移动到目的地。例如，数据管道可以监视文件系统目录中的新文件，并将其数据写入事件日志。另一个应用程序可以将事件流物化到数据库，或者增量地构建和细化搜索索引。</p><p>下图描述了周期性ETL作业和连续数据管道之间的区别</p><p><img src="/images/flink/usecases-datapipelines.png" alt=""></p><p>数据管道的优点是什么?<br>在定期ETL作业上使用连续数据管道的明显优势是减少了将数据移动到其目的地的延迟。此外，数据管道更加通用，可以用于更多的用例，因为它们能够持续地消耗和发出数据。</p><p>Flink如何支持数据管道?<br>许多常见的数据转换或充实任务都可以通过Flink的SQL接口(或表API)及其对用户定义函数的支持来实现。使用更加通用的DataStream API可以实现具有更高级需求的数据管道。Flink为各种存储系统(如Kafka、Kinesis、Elasticsearch和JDBC数据库系统)提供了丰富的连接器集。它还提供了用于文件系统的连续源，用于监视以时间限制方式编写文件的目录和接收器。</p>]]></content>
      
      
      <categories>
          
          <category> 实时计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成https证书并上传到阿里云控制台</title>
      <link href="2019/12/10/develop/ssl/"/>
      <url>2019/12/10/develop/ssl/</url>
      
        <content type="html"><![CDATA[<p>在装有openssl的系统中执行，window下可以使用win10子系统</p><span id="more"></span><h1 id="通过openssl生成Key"><a href="#通过openssl生成Key" class="headerlink" title="通过openssl生成Key"></a>通过openssl生成Key</h1><p><code>openssl genrsa -out xxx 1024</code></p><p>其中<code>xxx</code>指的是私钥存放的文件名</p><h1 id="生成cert证书"><a href="#生成cert证书" class="headerlink" title="生成cert证书"></a>生成cert证书</h1><p><code>openssl req -new -x509 -key x1 -out x2 -days 3650 -subj /CN=x3</code></p><ul><li>x1是之前生成的私钥文件</li><li>x2输出的地址</li><li>x3是待绑定的域名</li></ul><h1 id="上传到阿里云"><a href="#上传到阿里云" class="headerlink" title="上传到阿里云"></a>上传到阿里云</h1><p>打开控制台，将生成的私钥文件及cert文件写到对应的文本框即可</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flink实时计算之API的基本使用</title>
      <link href="2019/12/10/develop/flinkAPI/"/>
      <url>2019/12/10/develop/flinkAPI/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何通过flink进行实时数据计算，并结果写入<code>fafka</code>。基于<code>java1.8</code>,<code>flink1.9.1</code>，开始前需要先搭建<code>kafka</code></p><span id="more"></span><h1 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h1><p>通过如下命令创建工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate \</span><br><span class="line">    -DarchetypeGroupId&#x3D;org.apache.flink \</span><br><span class="line">    -DarchetypeArtifactId&#x3D;flink-quickstart-java \</span><br><span class="line">    -DarchetypeVersion&#x3D;1.9.0 \</span><br><span class="line">    -DgroupId&#x3D;wiki-edits \</span><br><span class="line">    -DartifactId&#x3D;wiki-edits \</span><br><span class="line">    -Dversion&#x3D;0.1 \</span><br><span class="line">    -Dpackage&#x3D;wikiedits \</span><br><span class="line">    -DinteractiveMode&#x3D;false</span><br></pre></td></tr></table></figure><br>也可以通过自己熟悉的IDE快速的创建。创建好后加入flink依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;flink-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;flink.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;flink-streaming-java_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;flink.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;flink-clients_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;flink.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.flink&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;flink-connector-kafka-0.11_2.11&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;flink.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h1 id="创建数据源"><a href="#创建数据源" class="headerlink" title="创建数据源"></a>创建数据源</h1><p> flink可以读取多种数据源，如kafka,socket，也可以自定义。下面来创建一种自定义的数据源形式，每隔100ms收集一个数字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class CustomDataSource extends RichSourceFunction&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private boolean running &#x3D; true;</span><br><span class="line">    private AtomicInteger index &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(SourceContext&lt;Integer&gt; ctx) throws Exception &#123;</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            int result &#x3D; index.getAndSet((int) (Math.random() * 10));</span><br><span class="line">            ctx.collect(result);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancel() &#123;</span><br><span class="line">        running &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算及写入"><a href="#计算及写入" class="headerlink" title="计算及写入"></a>计算及写入</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建执行环境，主要用作设置执行参数及读入外部数据源</span><br><span class="line">StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">&#x2F;&#x2F; 添加自定义的数据源</span><br><span class="line">DataStream&lt;Integer&gt; dataStream &#x3D; env.addSource(new CustomDataSource());</span><br><span class="line">&#x2F;&#x2F; 计算相同值的数据并计算和</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result &#x3D; dataStream.flatMap(new FlatMapFunction&lt;Integer, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void flatMap(Integer value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) throws Exception &#123;</span><br><span class="line">        out.collect(new Tuple2&lt;String, Integer&gt;(&quot;key:&quot; + value, value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).keyBy(&quot;f0&quot;)</span><br><span class="line">  .timeWindow(Time.seconds(10))</span><br><span class="line">   .reduce(new ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Tuple2&lt;String, Integer&gt; reduce(Tuple2&lt;String, Integer&gt; value1, Tuple2&lt;String, Integer&gt; value2) throws Exception &#123;</span><br><span class="line">            return new Tuple2&lt;String, Integer&gt;(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">result.addSink(new FlinkKafkaProducer011&lt;Tuple2&lt;String, Integer&gt;&gt;(&quot;broker list&quot;,</span><br><span class="line">        &quot;topic&quot;,</span><br><span class="line">        new KeyedSerializationSchema&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public byte[] serializeKey(Tuple2&lt;String, Integer&gt; element) &#123;</span><br><span class="line">                return element.f0.getBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public byte[] serializeValue(Tuple2&lt;String, Integer&gt; element) &#123;</span><br><span class="line">                return String.valueOf(element.f1).getBytes();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public String getTargetTopic(Tuple2&lt;String, Integer&gt; element) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure><p> 此时数据计算后都发到对应的fafka中</p><h1 id="将任务发布到flink集群中"><a href="#将任务发布到flink集群中" class="headerlink" title="将任务发布到flink集群中"></a>将任务发布到flink集群中</h1><p> 上面只是通过本地直接运行，功能测试通过后将代码打成jar，放到flink节点中执行。</p>]]></content>
      
      
      <categories>
          
          <category> 实时计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service Mesh (服务网格)</title>
      <link href="2019/03/26/develop/service-mesh/"/>
      <url>2019/03/26/develop/service-mesh/</url>
      
        <content type="html"><![CDATA[<p>服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求可以在这些拓扑中可靠的穿梭。在实际应用中，服务网格通常是由一系列轻量级的网格代理组成，他们与用用程序部署在一起，但应用程序不需要知道他们的存在。</p><span id="more"></span><h1 id="Service-Mesh特点"><a href="#Service-Mesh特点" class="headerlink" title="Service Mesh特点"></a>Service Mesh特点</h1><p>Service Mesh 有如下几个特点：</p><p>应用程序间通讯的中间层<br>轻量级网络代理<br>应用程序无感知<br>解耦应用程序的重试/超时、监控、追踪和服务发现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>p2p穿透NAT</title>
      <link href="2018/11/21/develop/p2p%E7%A9%BF%E9%80%8FNAT/"/>
      <url>2018/11/21/develop/p2p%E7%A9%BF%E9%80%8FNAT/</url>
      
        <content type="html"><![CDATA[<h1 id="NAT，NAPT"><a href="#NAT，NAPT" class="headerlink" title="NAT，NAPT"></a>NAT，NAPT</h1><p>网络地址转换（NAT,Network Address Translation),早期的NAT指的是Basic NAT（静态NAT），它在技术上比较简单一点，仅支持地址转换，不支持端口映射，这就需要对每一个当前连接都要对应一个IP地址，因此要维护一个公网的地址池。我们可以看出，Basic NAT一个明显的缺陷就是：同一时刻只能少量位于NAT后面机器能够与外部交互（<em>要看NAT有几个外网IP</em>）。后期的NAT基本都指的是NAPT（<em>网络地址端口转换</em>）了，这种方式支持端口映射并允许多台主机共享一个公用IP地址，这样就可以支持同时多个位于NAT后面的机器与外部进行交互，支持端口转换的NAT又可以分成两类：</p><ul><li>源地址转换（SNAT）</li><li>目的地址转换（NAT）</li></ul><span id="more"></span><h1 id="NAT带来的问题"><a href="#NAT带来的问题" class="headerlink" title="NAT带来的问题"></a>NAT带来的问题</h1><p>NAT在缓解IPv4地址紧张的同时，也带来了不少问题：</p><ul><li><strong>NAT使IP会话的保持失效变短</strong>。NAT设备建立的内网IP、端口到外网IP，端口的映射表是有保活期的，如果在一个超时时间内，该映射没有实际的数据传输，那么NAT会过期并回收这个映射表给其他通信链路（<em>IP和端口资源有限，其通信的链路是无限的</em>），为了避免这种通信链路提前被中断，很多应用层协议在设计时考虑一个连接保活机制，即在一段时间内没有数据需要发送，就主动发送一个NAT能感知的消息，这么做的目的就是避免NAT过期</li><li><strong>NAT在实现上将多个内部主机发出的连接复用到一个IP上，这就使依赖IP进行主机跟踪的机制都失效了</strong>。对于NAT后面的N多主机，在外部看来都是同一个主机（NAT设备），于是来自同一IP数据包一定是同一主机的判断就不准确，这样基于这个前提的机制都会有问题（如TCP的TIME_WAIT的回收和重用）。</li><li><strong>NAT工作机制依赖于修改IP包头的信息，这会妨碍一些安全协议的工作</strong> 。NAT篡改了IP地址、传输层口号及校验和</li><li><strong>NAT限制了一些高层协议（FTP，Quake, Sip)</strong>的Peer两端的P2P通信。一般情况下，NAT不允许外部的peer节点主动连接或发送数据包给NAT后的主机，主要是因为：<ul><li>出于安全考虑，避免来自网络外部的攻击，隐藏并保护网络内部的计算机</li><li>位于NAT后面的主机，对于主动进来的数据包，NAT一般不知道该路由给哪个主机（NAT设备上没有相关的转发项）</li></ul></li></ul><p>由于这种特性，那么在NAT环境下，实现P2P通信主要有如下步骤：</p><ol><li>在server的协助下，通信两端尝试相互连接，如果两端连接不成功后进入<em>第2步</em></li><li>这个步骤就是服务器中转（relay)，简单的说就是peer1将要发给peer2的数据发送给Server，然后由Server帮忙转发给peer2,peer2同理</li></ol><p>对于实现P2P通信，步骤1是大家下功夫最多的，其原因比较简单，就是步骤2需要消耗较多的服务器资源，成本比较高。步骤1实现P2P两个节点间的直接通信，在资源消耗和效率上都是比较好的。</p><h1 id="P2P通信穿越NAT的方法"><a href="#P2P通信穿越NAT的方法" class="headerlink" title="P2P通信穿越NAT的方法"></a>P2P通信穿越NAT的方法</h1><p>目前常见的技术有：</p><ul><li>应用层网关</li><li>中间件技术</li><li>打洞技术</li><li>Relay（服务器中转）</li></ul><h2 id="应用层网关"><a href="#应用层网关" class="headerlink" title="应用层网关"></a>应用层网关</h2><p>应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用带有ALG功能的NAT对特定应用层协议的支持和理解，在一个NAT网络检测到新的连接请求时，需要判断是否为已知应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。例如：下图，对于使用主动模式的FTP协议(PORT方式)，就需要AGL的支持了。<br><img src="/images/1500259554093_2094_1500259554660.jpg" alt=""><br>由于FTP协议通信需要两个TCP连接，一个是命令链路，用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。如上图，位于NAT后面的FTP client(192.168.1.2)首先发起一个TCP连接(命令链路)连上外网FTP Server(8.8.8.1)，然后发送PORT报文(192.168.1.2，1084)说自己在1084端口接收数据，然后进过ALG处理PORT报文变成(8.8.8.1，12487)，同NAT建立其一条(192.168.1.2，1084 &lt;—&gt;8.8.8.1，12487)映射。这样FTP Server发往(8.8.8.1，12487)的数据就会被转到(192.168.1.2，1084)，从而实现数据传输(如果没经过ALG处理，那么FTP Server直接连接192.168.1.2，1084是无法连接上的)。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>ALG技术是利用NAT本身的支持来进行NAT的穿越，这个方案有很大限制，主要的原因是ALG都是为特定协议的特定规范版本而开发的，然而不管是协议本身，还是协议的数量都在变化，这就使得ALG适应性不强。</p><h2 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术"></a>中间件技术</h2><p>这是一种通过开发通用方法解决NAT穿越问题的努力。与前者不同之处是，AGL技术中NAT网关是这一解决方案的唯一参与者，而中间件技术中客户端会参与网关公网映射信息的维护。UPnP就是这样一种方法，UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>NAT只要理解客户端的请求并按照要求去分配响应的映射转换表，不需要自己去分析客户端的应用层数据。网关映射请求可以为客户动态添加映射表项。此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。</p><h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><p>这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。</p><h2 id="打洞技术（Hole-Punching"><a href="#打洞技术（Hole-Punching" class="headerlink" title="打洞技术（Hole Punching)"></a>打洞技术（Hole Punching)</h2><p>Hole Punching技术是工作在运输层的技术，可以屏蔽上层应用层的差异，并且不需要NAT网关特定的支持，因此其通用性比较强，应用性也比较广。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>打洞技术的原理比较简单，就是NAT内网的节点需要在NAT上建立自己的一条转发映射关系(这就是所谓的在NAT上打下一个洞)，然后外网的节点就通过这个”洞”来进行通信。为描述方便，我们将一对IP地址和端口信息的组合称之为一个Endpoint，打洞原理可以简化为下面三个过程：</p><ul><li>首先位于NAT后的Peer1节点需要向外发送数据包，以便让NAT建立起内网Endpoint1(IP1、PORT1)和外网Endpoint2(IP2、PORT2)的映射关系；</li><li>然后通过某种方式将映射后的外网Endpoint2通知给对端节点Peer2；</li><li>最后Peer2往收到的外网Endpoint2发送数据包，然后该数据包就会被NAT转发给内网的Peer1</li></ul><p>如果全部会被转发给内网Peer1，那会不会太不安全了，只要知道内网Peer1的映射后的外网Endpoint2，就可以给穿透NAT给内网Peer1发送数据，这样内网Peer1不就很容易遭到攻击了？如果全部都不转发给内网Peer1，这样Peer1只能向外发数据，而无法收到外面的数据，严重影响Peer1的正常通信。那么，这就比较明了了，我们需要的是一部分可以转发，另外一部分不转发。这就涉及到NAT对外来数据包的一个过滤规则了，而疑问(1)提到的映射关系建立的规则，这涉及到NAT的Endpoint的映射规则。那么问题来了，有什么方法可以知道NAT的Endpoint映射规则和对外来数据包的过滤规则呢？</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>由上面原理的讨论我们知道，要实现打洞穿越NAT，首先需要知道NAT的行为规则(NAT的Endpoint映射规则和对外来数据包的过滤规则)，这样才能更好地实现打洞穿越。那NAT有哪些行为类型？有什么办法来侦测NAT的行为呢？</p><h4 id="NAT行为类型与侦测方法"><a href="#NAT行为类型与侦测方法" class="headerlink" title="NAT行为类型与侦测方法"></a>NAT行为类型与侦测方法</h4><p>NAT的行为类型和侦测方法是由STUN(首先在RFC3489中定义，英文全称是Simple Traversal of UDP Through NATs)协议来描述的，STUN协议包括了RFC3489、RFC5389、RFC5780、RFC5769几个系列文档。早期的STUN协议是由RFC3489（经典的STUN）来描述，其定义的NAT行为类型如下：</p><ol><li><p>Full Cone NAT - 完全锥形NAT<br>所有从同一个内网IP和端口号Endpoint1发送过来的请求都会被映射成同一个外网IP和端口号Endpoint2，并且任何一个外网主机都可以通过这个映射的Endpoint2向这台内网主机发送包。也就是外网所有发往Endpoint2的数据包都会被NAT转发给Endpoint1。由于对外部请求的来源无任何限制，因此这种方式虽然足够简单，但却不安全。</p></li><li><p>Restricted Cone NAT - 限制锥形NAT<br>它是Full Cone的受限版本：所有来自同一个内网Endpoint1的请求均被NAT映射成同一个外网Endpoint2，这与Full Cone相同。但不同的是，只有当内网Endpoint1曾经发送过报文给外部主机（假设其IP地址为IP3）后，外部主机IP3发往Endpoint2的数据包才会被NAT转发给Endpoint1。这意味着，NAT设备只向内转发那些来自于当前已知的外部主机的数据包，从而保障了外部请求来源的安全性</p></li><li><p>Port Restricted Cone NAT - 端口限制锥形NAT<br>它是Restricted Cone NAT的进一步受限版，与限制锥形NAT很相似，只不过它包括端口号PORT。只有当内网Endpoint1曾经发送过报文给外部Endpoint3(包括IP和端口了)，Endpoint3发往Endpoint2的数据包才会被NAT转发给Endpoint1。端口号PORT这一要求进一步强化了对外部报文请求来源的限制，从而较Restrictd Cone更具安全性。</p></li><li><p>Symmetric NAT - 对称NAT<br>上面的[1][2][3]所有的Cone NAT中，映射关系只和内网的源Endpoint1相关，只要源Endpoint1不变其都会被映射成同一个Endpoint2。而对称NAT的映射关系不只与源Endpoint1相关，还与目的Endpoint3相关。也就是源Endpoint1发往目的Endpoint30的请求被映射为Endpoint20，而源Endpoint1发往目的Endpoint31的请求，则被映射为Endpoint21了。此外，只有收到过内网主机发送的数据的外网主机才可以反过来向内网主机发送数据包。</p></li></ol><p>经典 STUN 定义的 NAT 行为类型是将NAT的Mapping Behavior （映射规则）和Filtering Behavior（过滤规则）统一来归类的，这样对Symmetric NAT类型的归类过于笼统，使得许多 NAT 不完全符合由它定义的类型。于是后来，RFC3489被废弃并由RFC5389来替代，在RFC5389中，将Mapping Behavior （映射规则）和Filtering Behavior（过滤规则）分开来，定义了3种Mapping Behavior （映射规则）和3种Filtering Behavior（过滤规则），一共有9种组合。为什么是3种呢？其实理由很简单，对于一个特定的内网源Endpoint1，影响其映射关系的因素不外乎就4种情况：</p><ol><li>目的IP和目的端口PORT都无关</li><li>目的IP和目的端口PORT都相关</li><li>仅仅目的IP相关</li><li>仅仅目的PORT相关</li></ol><p>对于4仅仅考虑一下PORT信息有点鸡肋，基本和1差不多，于是把4去掉了。同样，对于过滤规则也一样。3种Mapping Behavior （映射规则）和 Filtering Behavior（过滤规则）如下：</p><p>Mapping Behavior:</p><ol><li><p>Endpoint-Independent Mapping<br>对于一个内网的EndpointP，其映射的外网EndpointG是基本固定的，不会随着通信外部主机的不同而变化。</p></li><li><p>Address and Port-Dependent Mapping<br>对于一个内网的EndpointP，如果与之通信的外部为EndpointGB1，那么EndpointP就会被NAT映射成EndpointG1；如果与之通信的外部为EndpointGB2，那么EndpointP就会被NAT映射成EndpointG2。也就是只要之通信的外部为EndpointGB发生变化，那么映射的外网EndpointG就会变化。</p></li><li><p>Address-Dependent Mapping<br>对于一个内网的EndpointP，如果与之通信的外部为EndpointGB1，那么EndpointP就会被NAT映射成EndpointG1；如果与之通信的外部为EndpointGB2(如果EndpointGB2的IP和EndpointGB1的相同)，那么EndpointP同样会被NAT映射成EndpointG1，否则就会被NAT映射成EndpointG2。也就是只要之通信的外部为EndpointGB的IP发生变化，那么映射的外网EndpointG就会变化。</p></li></ol><p>Filtering Behavior:</p><ol><li><p>Endpoint-Independent Filtering<br>对于这种过滤类型，NAT在在自己的一个外网EndpointG1收到数据包，只要找到与之对应的内网EndpointP1，NAT就会转发这个数据包给相应的内网EndpointP1，不管这个数据包的来源是那里。(一般来说，这样过滤规则的NAT是比较少的，因为这样的安全系数比较低)</p></li><li><p>Address and Port-Dependent Filtering<br>对于这种过滤类型，NAT在自己的一个外网EndpointG1收到来源是EndpointGA1数据包，这个时候NAT要判断自己是否曾经通过自己的EndpointG1给EndpointGA1发送过数据包，如果曾经发过，那么NAT就允许该数据包通过NAT并路由给内网与之对于的内网EndpointP1；如果没发过，那么NAT会不允许该数据包通过NAT。</p></li><li><p>Address-Dependent Filtering<br>对于这种过滤类型，NAT在自己的一个外网EndpointG1收到来源是EndpointGA1数据包，这个时候NAT要判断自己是否曾经通过自己的EndpointG1给和EndpointGA1的IP相同的机器发送过数据包(这里会忽略端口)，如果曾经发过，那么NAT就允许该数据包通过NAT并路由给内网与之对于的内网EndpointP1；如果没发过，那么NAT会不允许该数据包通过NAT。</p></li></ol><p>RFC5389只是定义了协议的相关属性、机制、报文结构以及一些相关的安全注意点等等，并有没对怎么进行完整的NAT类型侦测做介绍。而对完整NAT类型侦测过程主要由RFC5780这个文档来描述。完整的NAT类型侦测的过程主要在RFC5780文档的4.3和4.4节，主要分为NAT映射规则（Determining NAT Mapping Behavior）和NAT过滤规则（Determining NAT Filtering Behavior），下面对具体的侦测过程做介绍：</p><p>要进行NAT类型的侦测，需要一个具有双公网IP的服务器来协助侦测，我们称该服务器为STUN Server。假设STUN Server的双IP分别为IP_SA(125.227.152.3)和IP_SB(125.227.152.4) 监听的两个端口分别为PORT_SA(4777)和PORT_SB(4888)，客户端A的内网和端口分别为IP_CA(10.70.142.12)和PORT_CA(1234)。</p><ol><li><p>客户端A以IP_CA:PORT_CA给STUN Server的IP_SA:PORT_SA发送一个bind请求，STUN server以IP_SA:PORT_SA给客户端A的IP_CA:PORT_CA回复响应，响应内容大体为：（NAT映射后的IP地址和端口为：IP_MCA1:PORT_MCA1，STUN Server的另外一个IP地址和端口为：IP_SB:PORT_SB）。这个时候客户端判断，如果IP_CA:PORT_CA == IP_MCA1:PORT_MCA1，那么该客户端是拥有公网IP的，NAT类型侦测结束。</p></li><li><p>客户端A以IP_CA:PORT_CA给STUN server的IP_SB:PORT_SA(相对步骤1 ip改变了)发送一个bind请求，STUN server以IP_SB:PORT_SA给客户端A的IP_CA:PORT_CA回复响应，响应内容大体为：（NAT映射后的IP地址和端口为：IP_MCA2:PORT_MCA2）。这个时候客户端判断，如果IP_MCA1:PORT_MCA1 == IP_MCA2:PORT_MCA2，那么NAT是Endpoint Independent Mapping的映射规则，也就是同样的内网地址IP_CA:PORT_CA经过这种NAT映射后的IP_M:PORT_M是固定不变的；如果IP_MCA1:PORT_MCA1 != IP_MCA2:PORT_MCA2,那么就要进行下面的第3步测试。</p></li><li><p>客户端A以IP_CA:PORT_CA给STUN server的IP_SB:PORT_SB(相对步骤1 ip和port改变了)发送一个bind请求，STUN server以IP_SB:PORT_SB给客户端A的IP_CA:PORT_CA回复响应，响应内容大体为：（NAT映射后的IP地址和端口为：IP_MCA3:PORT_MCA3）。这个时候客户端判断，如果IP_MCA2:PORT_MCA2== IP_MCA3:PORT_MCA3，那么NAT是Address Dependent Mapping的映射规则，也就是只要是目的IP是相同的，那么同样的内网地址IP_CA:PORT_CA经过这种NAT映射后的IP_M:PORT_M是固定不变的；如果IP_MCA2:PORT_MCA2!= IP_MCA3:PORT_MCA3，那么NAT是Address and Port Dependent Mapping，只要目的IP和PORT中有一个不一样，那么同样的内网地址IP_CA:PORT_CA经过这种NAT映射后的IP_M:PORT_M是不一样的。</p></li></ol><p>以上三个步骤是进行Mapping Behavior的侦测，下面两个步骤是进行Filtering Behavior侦测</p><ol start="4"><li><p>客户端A以IP_CA:PORT_CA给STUN server的IP_SA:PORT_SA发送一个bind请求（请求中带CHANGE-REQUEST attribute来要求stun server改变IP和PORT来响应），STUN server以IP_SB:PORT_SB给客户端A的IP_CA:PORT_CA回复响应。如果客户端A能收到STUN server的响应，那么NAT是Endpoint-Independent Filtering的过滤规则，也就是只要给客户端A的IP_CA:PORT_CA映射后的IP_MCA:PORT_MCA地址发送数据都能通过NAT到达客户端A的IP_CA:PORT_CA（这种过滤规则的NAT估计很少）。如果不能收到STUN server的响应，那么需要进行下面的第五步测试。</p></li><li><p>客户端A以IP_CA:PORT_CA给STUN server的IP_SA:PORT_SA发送一个bind请求（请求中带CHANGE-REQUEST attribute来要求stun server改变PORT来响应），STUN server以IP_SA:PORT_SB给客户端A的IP_CA:PORT_CA回复响应。如果客户端A能收到STUN server的响应，NAT是Address-Dependent Filtering的过滤规则，也就是只要之前客户端A以IP_CA:PORT_CA给IP为IP_D的主机发送过数据，那么在NAT映射的有效期内，IP为IP_D的主机以任何端口给客户端A的IP_CA:PORT_CA映射后的IP_MCA:PORT_MCA地址发送数据都能通过NAT到达客户端A的IP_CA:PORT_CA；如果不能收到响应，NAT是Address and Port-Dependent Filtering的过滤规则，也即是只有之前客户端A以IP_CA:PORT_CA给目的主机的IP_D:PORT_D发送过数据，那么在NAT映射的有效期内，只有以IP_D:PORT_D给客户端A的IP_CA:PORT_CA映射后的IP_MCA:PORT_MCA地址发送数据才能通过NAT到达客户端A的IP_CA:PORT_CA。</p></li></ol><p>通过以上5个步骤就能完成完整的NAT类型侦测。将NAT映射规则和过滤规则组合起来就形成9中不同的NAT行为类型。</p><ol><li>Endpoint Independent Mapping和Endpoint-Independent Filtering组合对应于RFC3489中的Full Cone NAT</li><li>Endpoint Independent Mapping和Address-Dependent Filtering组合对应于RFC3489中的Restricted Cone NAT。</li><li>Endpoint Independent Mapping和Address and Port-Dependent Filtering组合对应于RFC3489中的Port Restricted Cone NAT。</li><li>Address and Port-Dependent Mapping和Address and Port-Dependent Filtering组合是RFC3489中所说的Symmetric NAT。<br>可见RFC3489只描述了9种NAT组合行为类型中的4种。最后一个文档rfc5769，定义了一些STUN协议的测试数据用于测试STUN server的正确性。</li></ol><h4 id="NAT打洞过程"><a href="#NAT打洞过程" class="headerlink" title="NAT打洞过程"></a>NAT打洞过程</h4><p>“打洞”方式穿越NAT有两种形式：TCP”打洞”和UDP”打洞”。原理上，TCP”打洞”与UDP”打洞”是没有本质的区别的。然而在实现上，TCP”打洞”的成功率远没UDP”打洞”的成功率高，其主要原因有三：</p><ol><li><p>有些NAT防火墙策略对TCP协议不是很友好。有些NAT的防火墙策略不允许来路不明的外部向内网机器发起TCP连接。由于TCP是有连接的，NAT比较容易分清哪些是NAT    内网机器主动进行通信的外部节点，这样防火墙策略比较明确。而UDP是无连接的，没有连接来标明一个数据流，协议比较简单，这样NAT支持的比较多。</p></li><li><p>TCP协议本身。由于TCP的TIME_WAIT状态引起，同一个NAT后面的其他主机发起的连接被误判。</p></li><li><p>TCP协议的实现API。因为标准的Berkeley sockets API是围绕C/S编程而设计的。这个API通过connect()允许一个TCP流套接字初始化一个向外的连接，通过listen()和 accept()监听一个外入的连接，一个套接字不能既用来监听又用来初始化向外的连接。更进一步讲， TCP套接字通常与本地主机上的TCP端口一一对应：一个套接字绑定到本地主机机上的某个端口后，另一个套接字就不能再绑定到该端口。然而TCP打洞要成功，需要一个本地的TCP端口既可以监听外入的连接，同时又可以发起多个向外的连接。幸运的是，所有主流的操作系统都支持一个特殊的socket选项SO_REUSEADDR，它运行应用程序绑定多个设置了该选项的套接字到同一端口。BSD系统引入了SO_REUSEPORT选项来控制端口重用，从而把端口重用和地址重用相分离。在这样的系统中，两个选项都需要被设置。尽管如此，要进行TCP打洞需要进行TCP三次握手的同时打开，但是有些TCP/IP的实现，可能不支持这种同时打开的情况，这样也就无法建立TCP连接了。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乌合之众</title>
      <link href="2018/06/27/reading/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/"/>
      <url>2018/06/27/reading/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/</url>
      
        <content type="html"><![CDATA[<p>《乌合之众》，作者是古斯塔夫.勒庞（法国著名社会心理学家，群体心理学创始人)，这本书主要研究群体时代的大众心理。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>intellij激活</title>
      <link href="2018/06/27/util/intellij/"/>
      <url>2018/06/27/util/intellij/</url>
      
        <content type="html"><![CDATA[<p>使用java-agent方式激活intellij激活，有效期可到2089年</p><span id="more"></span><ol><li>下载java-agent，<a href="/files/intellij/normal/jetbrains-agent.jar">下载链接</a></li><li>选择使用方式打开IDE，菜单栏点击<code>help-&gt;Edit Custom VM Options</code></li><li>在最后一行添加agent，<code>-javaagent:/path/jetbrains-agent.jar</code>,<em>注意不同操作系统分隔符不同，windows下是:c\path\jetbrains-agent.jar</em></li><li>重启IDE</li><li>输入激活码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim&#x2F;8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk&#x2F;ZGtNIUOczUQ0iGKKnSSsfQ&#x2F;3UoMv0q&#x2F;yJcfvj+me5Zd&#x2F;gfaisCCMUaGjB&#x2F;lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD&#x2F;&#x2F;dLT+HuZdc1sAIYrw&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></li></ol><h1 id="rubymine破解"><a href="#rubymine破解" class="headerlink" title="rubymine破解"></a>rubymine破解</h1><p>已经在rubymine2020.1下破解成功</p><p>步骤跟上面一样，更换下agent文件，<a href="/files/intellij/rubymine/jetbrains-agent.jar">下载链接</a></p><p>激活码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim&#x2F;8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk&#x2F;ZGtNIUOczUQ0iGKKnSSsfQ&#x2F;3UoMv0q&#x2F;yJcfvj+me5Zd&#x2F;gfaisCCMUaGjB&#x2F;lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD&#x2F;&#x2F;dLT+HuZdc1sAIYrw&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></p><h1 id="intellij-2020-3"><a href="#intellij-2020-3" class="headerlink" title="intellij 2020.3"></a>intellij 2020.3</h1><p>agent:<code>-javaagent:/Users/lintao/.BetterIntelliJ/BetterIntelliJ-1.16.jar</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BISACXYELK-eyJsaWNlbnNlSWQiOiJCSVNBQ1hZRUxLIiwibGljZW5zZWVOYW1lIjoiQ2hpbmFOQiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjA5OS0xMi0zMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJwYWlkVXBUbyI6IjIwOTktMTItMzEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTIiwicGFpZFVwVG8iOiIyMDk5LTEyLTMxIiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjAwNzI4RVBKQTAwODAwNiIsImhhc2giOiIxNTAyMTM1NC8wOi0xMjUxMTE0NzE3IiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-H7NUmWcLyUNV1ctnlzc4P79j15qL56G0jeIYWPk&#x2F;HViNdMg1MqPM7BR+aHR28yyuxK7Odb2bFDS8CeHNUtv7nT+4fUs85JJiqc3wc1psRpZq5R77apXLOmvmossWpbAw8T1hOGV9IPUm1f2O1+kLBxrOkdqPpv9+JanbdL7bvchAid2v4&#x2F;dyQMBYJme&#x2F;feZ0Dy2l7Jjpwno1TeblEAu0KZmarEo15or5RUNwtaGBL5+396TLhnw1qL904&#x2F;uPnGftjxWYluLjabO&#x2F;uRu&#x2F;+5td8UA&#x2F;39a1nvGU2nORNLk2IdRGIheiwIiuirAZrII9+OxB+p52i3TIv7ugtkw0E3Jpkw&#x3D;&#x3D;-MIIDlzCCAn+gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1KZXRQcm9maWxlIENBMCAXDTE4MTEwMTEyMjk0NloYDzIwOTkwODA5MDIyNjA3WjBoMQswCQYDVQQGEwJDWjEOMAwGA1UECBMFTnVzbGUxDzANBgNVBAcTBlByYWd1ZTEZMBcGA1UEChMQSmV0QnJhaW5zIHMuci5vLjEdMBsGA1UEAxMUcHJvZDN5LWZyb20tMjAxODExMDEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCdXyaNhhRySH1a8d7c8SlLLFdNcQP8M3gNnq7gudcpHC651qxRrN7Qks8gdXlIkA4u3&#x2F;lp9ylp95GiIIDo4ydYje8vlTWDq02bkyWW&#x2F;G7gZ3hkbBhRUK&#x2F;WnNyr2vwWoOgwx5CfTRMjKkPkfD&#x2F;+jffkfNfdGmGcg9yfnqPP9&#x2F;AizKzWTsXSeS+0jZ8Nw5tiYFW+lpceqlzwzKdTHug7Vs0QomUPccRtZB&#x2F;TBBEuiC7YzrvLg4Amu0I48ETAcch&#x2F;ztt00nx&#x2F;oj&#x2F;fu1DTnz4Iz4ilrNY+WVIEfDz&#x2F;n3mz+PKI9kM+ZeB0jAuyLsiC7skGpIVGX&#x2F;2HqmZTtJKBZCoveAiVAgMBAAGjgZkwgZYwSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TAJBgNVHRMEAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAsGA1UdDwQEAwIFoDAdBgNVHQ4EFgQUYSkb2hkZx8swY0GRjtKAeIwaBNwwDQYJKoZIhvcNAQELBQADggEBAJZOakWgjfY359glviVffBQFxFS6C+4WjYDYzvzjWHUQoGBFKTHG4xUmTVW7y5GnPSvIlkaj49SzbD9KuiTc77GHyFCTwYMz+qITgbDg3&#x2F;ao&#x2F;x&#x2F;be4DD&#x2F;k&#x2F;byWqW4Rb8OSYCshX&#x2F;fNI4Xu+hxazh179taHX4NaH92ReLVyXNYsooq7mE5YhR9Qsiy35ORviQLrgFrMCGCxT9DWlFBuiPWIOqN544sL9OzFMz+bjqjCoAE&#x2F;xfIJjI7H7SqGFNrx&#x2F;8&#x2F;IuF0hvZbO3bLIz+BOR1L2O+qT728wK6womnp2LLANTPbwu7nf39rpP182WW+xw2z9MKYwwMDwGR1iTYnD4&#x2F;Sjw&#x3D;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配之KMP</title>
      <link href="2017/07/10/develop/kmp/"/>
      <url>2017/07/10/develop/kmp/</url>
      
        <content type="html"><![CDATA[<p>已知有一子串<strong>A</strong>，当需要判断另一个字符串<strong>B</strong>是否在<strong>A</strong>中，最直观的解决方案就是两个循环嵌套，如下</p><ol><li>取<strong>A</strong>,<strong>B</strong>中的第一个字符，</li><li>判断两个位置的字符是否相等，</li><li>如果相等，则两处指针分别往后移动一位</li><li>如果不相等，则取<strong>A</strong>的第二个字符，从<strong>B</strong>的第一个字符重新开始匹配</li><li>当前匹配到<strong>B</strong>的最后一位，则表示匹配成功，反之匹配失败</li></ol><p>从这个步骤中可以看到，中间有很多重复的判断，那该怎么使用中间计算过的值，这就用到了本文中介绍的<strong>KMP</strong>算法。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。<br><span id="more"></span></p><p>我们假设主串是a，模式串b。在模式中与主串匹配的过程中，当遇到不可匹配的字符时，我们希望从中找到规律，将模式串往后多移动几位，避免每次都重复的判断，跳过那些一定不会匹配的子串。</p><p>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p><p>在介绍前需要先了解下字符串的前缀，后缀。字符串前缀指的是除去最后一位，与首字符对齐的所有子串。<br>后缀是指除去首字符，与最后一位对齐的所有子串。</p><p>如字符串<code>ababa</code>的前缀，后缀如下：</p><table><thead><tr><th>字符串</th><th>前缀</th><th>后缀</th></tr></thead><tbody><tr><td>ababa</td><td>a,ab,aba,abab</td><td>a,ba,aba,baba</td></tr></tbody></table><p>当在<strong>j</strong>位置时匹配失败时，从已经匹配成功的子串中找到其后缀与前缀公共的最长子串，假设长度为：<strong>k</strong>，那将模式串一次性的往后移动<strong>j-k</strong>位。KMP提前构建一个数组，用来存储模式串中每个最长前后缀子串的前缀最后一位的下标，我们把这个数组定义为<strong>next</strong>数组，有时候也叫做<strong>失效函数</strong>。</p><p>模式串 a b a b a c d</p><table><thead><tr><th>匹配到位置</th><th>模式子串</th><th>公共最长子串</th><th>前缀下标</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>只有一个子串，不存在子串</td><td>-1</td></tr><tr><td>1</td><td>ab</td><td>ab,没有公共子串</td><td>-1</td></tr><tr><td>2</td><td>aba</td><td>a</td><td>0</td></tr><tr><td>3</td><td>abab</td><td>ab</td><td>1</td></tr><tr><td>4</td><td>ababa</td><td>aba</td><td>2</td></tr><tr><td>5</td><td>ababac</td><td>不存在</td><td>-1</td></tr><tr><td>6</td><td>最后一位不需要再计算，如果最后一位都匹配成功，那整个都已经匹配成功了</td></tr></tbody></table><p>有了next数组，那就可以很容易实现KMP算法，我们先假设next数组已经计算成功，则整个匹配的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param a 主串</span><br><span class="line">* @param b 模式串</span><br><span class="line">*&#x2F;</span><br><span class="line">public static int kmp(char[] a, char[] b)&#123;</span><br><span class="line">    int[] next &#x3D; getNexts(b);</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    for(int i&#x3D;0; i&lt;a.length; i++)&#123;</span><br><span class="line">        while(j&gt;0 &amp;&amp; a[i] !&#x3D; b[j])&#123;</span><br><span class="line">            &#x2F;&#x2F; 因为j位置本身就不匹配，公共子串肯定是在前一位</span><br><span class="line">            j &#x3D; next[j-1] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[i] &#x3D;&#x3D; b[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &#x3D;&#x3D; b.length)&#123;</span><br><span class="line">            return i - b.length + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="失效函数的计算"><a href="#失效函数的计算" class="headerlink" title="失效函数的计算"></a>失效函数的计算</h1><p>现在来看next数组是如何计算出来的。<br>当然这里有一个简单的办法就是把模式串中的所有子串都遍历出来，找出公共最长的子串，但是这个效率非常低。</p><p>我们按照下标从小到大，依次计算next数组的值。当要计算<code>next[i]</code>的时候，前面的<code>next[0]</code>,<code>next[1]</code>,..<code>next[i-1]</code>都已经计算出来了，那能否快速根据计算出来的next值推导出next[i]值？</p><p>如果<code>next[i-1]=k-1</code>,也就是说，子串<code>b[0,k-1]</code>就是b[0,i-1]<code>的</code>的最长可匹配前缀子串。如果子串<code>b[0,k-1]</code>的下一个字符b[k]，与b[0,i-1]的下一个字符b[i]匹配，那b[0,k]就是b[0,i]的最长可匹配子串，所以<code>next[i]=k</code>。但是如果b[k] != b[i]时呢？这个时候就不能简单通过next[i-1]得到了。</p><p>我们假设b[0,i]的最长可匹配后缀子串是b[r,i]。如果把最后一个字符去掉，那b[r,i-1]肯定是b[0,i-1]的公共的前后缀子串，但注意的是：不一定是最长子串。所以，既然b[0,i-1]最长可匹配的前缀子串下一个字符不一定等于b[i]，那我们就可以从b[0,i-1]的次长公共前缀的下一个字符找。换句话就是说最长串的下一个字符不相等时，就找第二长的子串，从第二长的子串的下一个字符找起。这时候之前的子串的前缀下标都已经计算好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param m 模式串</span><br><span class="line">*&#x2F;</span><br><span class="line">private static int[] getNexts(char[] m)&#123;</span><br><span class="line">    int[] next &#x3D; new int[m.length];</span><br><span class="line">    int k &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; 第一位不存在，预先设置</span><br><span class="line">    next[0]&#x3D;-1;</span><br><span class="line">    for(int i&#x3D;1 ;i&lt;m.length; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;一个都未匹配的忽略;找到最后一个不匹配的位置，当其下一个字符不匹配时，从其次长子串中继续匹配,相等时不会进入循环，直接检查下一个字符是否相等</span><br><span class="line">        while(k !&#x3D;-1 &amp;&amp; m[i] !&#x3D; m[k + 1])&#123;</span><br><span class="line">            k &#x3D; next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断下一个字符是否相等</span><br><span class="line">        if(m[k + 1] &#x3D;&#x3D; m[i])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] &#x3D; k;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>标准版HotSpot虚拟机垃圾收集优化</title>
      <link href="2017/07/10/develop/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>2017/07/10/develop/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>垃圾收集器（GC）是一种内存管理工具。它通过以下操作实现自动内存管理：</p><ul><li>将对象分配给年轻一代，并将老化的对象提升为老一代。</li><li>通过并行标记阶段查找旧一代中的活动对象。当Java堆总占用量超过默认阈值时，Java HotSpot VM会触发标记阶段。</li><li>通过并行复制压缩活动对象来恢复可用内存。请参阅并行收集器和垃圾优先的垃圾收集器部分</li></ul><span id="more"></span><p>什么时候选择垃圾收集器很重要？对于某些应用程序，答案永远是不可能的。也就是说，在存在垃圾收集的情况下，应用程序可以在频率和持续时间适度的暂停下表现良好。但是，对于大类应用程序却不是这种情况，尤其是那些具有大量数据（多个千兆字节），许多线程和高事务处理率的应用程序。</p><p>阿姆达尔定律（给定问题中的并行加速受问题的顺序部分限制）意味着大多数工作负载无法完美并行化；某些部分始终是顺序的，不能从并行性中受益。Java平台也是如此。特别是，Java SE 1.4之前的Oracle针对Java平台的虚拟机不支持并行垃圾收集，因此，垃圾收集对多处理器系统的影响相对于其他并行应用程序而言会增加。</p><p>下图“比较垃圾收集中所用时间的百分比”中的图形对理想的系统进行了建模，该系统除了垃圾收集（GC）之外，还具有很好的可伸缩性。红线表示应用程序仅在单处理器系统上花费1％的时间进行垃圾回收。在具有32个处理器的系统上，这意味着吞吐量损失超过20％。洋红色线显示，对于一个应用程序来说，垃圾回收有10％的时间（在单处理器应用程序中垃圾回收的时间不算太长），当扩展到32个处理器时，将损失超过75％的吞吐量。<br><img src="/images/jsgct_dt_005_gph_pc_vs_tp.png" alt=""></p><p>这表明，在小型系统上进行开发时，可以忽略的速度问题可能会在扩展到大型系统时成为主要瓶颈。但是，在减少这种瓶颈方面进行小的改进可以提高性能。对于足够大的系统，有必要选择合适的垃圾收集器并在必要时进行调整。</p><p>串行收集器通常适合大多数“小型”应用程序（那些需要高达大约100兆字节（在现代处理器上为MB）的堆。其他收集器具有额外的开销或复杂性，这是特殊行为的代价。不需要备用收集器的特殊行为，请使用串行收集器。一种不希望串行收集器成为最佳选择的情况是大型，线程密集的应用程序，该应用程序在具有大量内存和两个内存的计算机上运行在此类服务器级计算机上运行应用程序时，默认情况下会选择并行收集器</p><h1 id="人体工程学"><a href="#人体工程学" class="headerlink" title="人体工程学"></a>人体工程学</h1><p>人机工程学是Java虚拟机（JVM）和垃圾收集调优（例如基于行为的调优）提高应用程序性能的过程。JVM为垃圾收集器，堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整会动态调整堆的大小，以满足应用程序的指定行为。</p><p>垃圾收集器，堆和运行时编译器的默认选择</p><p>称为服务器类机器的一类机器已定义为具有以下内容的机器：</p><ul><li>2个或更多物理处理器</li><li>2 GB或更多的物理内存</li></ul><p>在服务器级计算机上，默认情况下选择以下内容：</p><ul><li>最大堆大小为物理内存的1/4，最大为1 GB</li><li>吞吐量垃圾收集器</li><li>初始堆大小为1/64的物理内存，最大为1 GB</li><li>服务器运行时编译器</li></ul><h2 id="基于行为的调整"><a href="#基于行为的调整" class="headerlink" title="基于行为的调整"></a>基于行为的调整</h2><p>对于并行收集器，Java SE提供了两个垃圾收集调整参数，这些参数基于实现应用程序的指定行为：最大暂停时间目标和应用程序吞吐量目标。（这两个选项在其他收集器中不可用。）请注意，这些行为不能始终得到满足。该应用程序需要足够大的堆，以至少容纳所有实时数据。此外，最小堆大小可能会阻止达到这些期望的目标。</p><h2 id="最大暂停时间目标"><a href="#最大暂停时间目标" class="headerlink" title="最大暂停时间目标"></a>最大暂停时间目标</h2><p>暂停时间是垃圾收集器停止应用程序并恢复不再使用的空间的持续时间。最大暂停时间目标的目的是限制这些暂停中的最长时间。垃圾回收器会保持平均的停顿时间和该平均值的方差。平均值是从执行开始时获取的，但经过加权后，最近的暂停次数会增加。如果平均时间加上暂停时间的方差大于最大暂停时间目标，则垃圾回收器认为未达到目标。</p><p>最大暂停时间目标是通过命令行选项指定的-XX:MaxGCPauseMillis=<nnn>。这被解释为垃圾收集器的提示，要求暂停时间为<nnn>毫秒或更短。垃圾收集器将调整Java堆大小以及与垃圾收集相关的其他参数，以使垃圾收集暂停时间短于<nnn>毫秒。默认情况下，没有最大暂停时间目标。这些调整可能导致垃圾回收器更频繁地发生，从而降低了应用程序的整体吞吐量。垃圾收集器会尝试在吞吐量目标之前达到任何暂停时间目标。但是，在某些情况下，无法达到所需的暂停时间目标。</p><h2 id="吞吐量目标"><a href="#吞吐量目标" class="headerlink" title="吞吐量目标"></a>吞吐量目标</h2><p>吞吐量目标是根据收集垃圾所花费的时间和垃圾收集之外所花费的时间（称为应用时间）来衡量的。目标由命令行选项指定-XX:GCTimeRatio=<nnn>。垃圾收集时间与应用程序时间的比率为1 /（1 + <nnn>）。例如，-XX:GCTimeRatio=19将垃圾收集目标设置为目标1/20或总时间的5％。</p><p>垃圾收集所花费的时间是年轻一代和老一代收集的总时间。如果没有达到吞吐量目标，那么将增加世代的大小，以增加应用程序在集合之间运行的时间。</p><h2 id="足迹目标"><a href="#足迹目标" class="headerlink" title="足迹目标"></a>足迹目标</h2><p>如果已满足吞吐量和最大暂停时间目标，则垃圾收集器将减小堆的大小，直到无法满足其中一个目标（始终是吞吐量目标）。然后解决未实现的目标。</p><h2 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h2><p>除非您知道需要的堆大于默认的最大堆大小，否则不要为堆选择最大值。选择适合您的应用程序的吞吐量目标。</p><p>堆将增长或缩小到可以支持所选吞吐量目标的大小。应用程序行为的更改可能导致堆增大或缩小。例如，如果应用程序开始以更高的速率分配，堆将增长以保持相同的吞吐量。</p><p>如果堆增长到最大大小，并且无法满足吞吐量目标，则最大堆大小对于吞吐量目标而言太小。将最大堆大小设置为接近平台上总物理内存但不会导致应用程序交换的值。再次执行该应用程序。如果仍然不能满足吞吐量目标，则对于平台上的可用内存，应用程序时间目标太高。</p><p>如果可以达到吞吐量目标，但暂停时间太长，则选择最大暂停时间目标。选择最大暂停时间目标可能意味着您的吞吐量目标将无法实现，因此请选择对应用程序可接受的折衷值。</p><p>通常，随着垃圾收集器试图满足竞争目标，堆的大小会振荡。即使应用程序已达到稳定状态，也是如此。实现吞吐量目标（可能需要更大的堆）的压力与目标竞争，以获得最大的暂停时间和最小的占用空间（这两者都可能需要小的堆）。</p><h1 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h1><p>Java SE平台的优势之一在于，它使开发人员免受内存分配和垃圾回收的复杂性的困扰。但是，当垃圾收集是主要瓶颈时，了解此隐藏实现的某些方面很有用。垃圾收集器对应用程序使用对象的方式进行了假设，并且这些反映在可调整的参数中，可以调整这些参数以提高性能而不会牺牲抽象的力量。</p><p>如果无法从正在运行的程序中的任何指针访问对象，则该对象被视为垃圾。最简单的垃圾回收算法会遍历每个可访问的对象。剩下的任何对象都被视为垃圾。这种方法所花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序是不允许的。</p><p>虚拟机结合了许多不同的垃圾收集算法，这些算法使用分代收集进行组合。当幼稚的垃圾收集检查堆中的每个活动对象时，分代收集利用大多数应用程序的经验观察到的属性，以最大程度地减少回收未使用的（垃圾）对象所需的工作。这些观察到的特性中最重要的是弱代假设，该假设指出大多数物体只能存活很短的时间。</p><p>下图“对象生命周期的典型分布”中的蓝色区域是对象生命周期的典型分布。x轴是对象寿命，以分配的字节为单位。y轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后不久即可回收的对象（换句话说，已“死亡”）。例如，迭代器对象通常在单个循环期间仍处于活动状态。<br><img src="/images/jsgct_dt_003_alc_vs_srvng.png" alt=""></p><p>有些对象的寿命更长，因此分布向右延伸。例如，通常有一些在初始化时分配的对象，这些对象一直存在，直到进程退出。在这两个极端之间的是在某些中间计算过程中存在的对象，在这里将其视为初始峰右边的肿块。一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。通过关注大多数对象“早逝”这一事实，可以进行有效的收集。</p><p>为了针对这种情况进行优化，内存要分代管理（存储着不同年龄对象的内存池）。当世代填满时，垃圾回收会在每个世代中发生。绝大多数对象分配在专用于年轻对象（年轻一代）的池中，并且大多数对象在那里死亡。当年轻一代填满时，会导致次要收藏只收集年轻一代；不回收其他世代的垃圾。假设弱的世代假设成立并且年轻一代中的大多数对象都是垃圾并且可以回收，可以优化次要集合。首先，这种收集的费用与所收集的有生命物体的数量成正比；可以很快收集到充满死亡物体的年轻一代。通常，在每个次要收藏期间，来自年轻世代的尚存对象的一部分会移交给终身代。最终，保有权的一代将填满并且必须被收集，从而导致大量的收集，其中收集了整个堆。主要集合的持续时间通常比次要集合的持续时间长得多，因为涉及的对象数量大得多。</p><p>如“ 人体工程学”部分所述，人体工程学动态选择垃圾收集器，以在各种应用程序上提供良好的性能。串行垃圾收集器是为具有小型数据集的应用程序设计的，其默认参数被选择为对大多数小型应用程序有效。并行或吞吐量垃圾收集器旨在与具有中大型数据集的应用程序一起使用。人体工程学选择的堆大小参数以及自适应大小策略的功能旨在为服务器应用程序提供良好的性能</p><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>有两种主要的垃圾收集性能度量：</p><ul><li>吞吐量是长时间内未用于垃圾回收的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。</li><li>暂停是指由于正在进行垃圾回收而导致应用程序无响应的时间。</li></ul><p>用户对垃圾回收有不同的要求。例如，有些人认为Web服务器的正确度量标准是吞吐量，因为垃圾收集期间的暂停可能是可以容忍的，或者可能被网络延迟所掩盖。但是，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。</p><p>一些用户对其他注意事项敏感。足迹是流程的工作集，以页和缓存行为单位。在具有有限物理内存或许多进程的系统上，占用空间可能决定可伸缩性。及时性是当一个物体变得死亡之间的时间当内存可用，分布式系统，包括远程方法调用（RMI）的重要考虑因素。</p><p>通常，为特定世代选择大小是这些考虑之间的权衡。例如，一个非常大的年轻一代可以最大化吞吐量，但是这样做会以占用空间，及时性和暂停时间为代价。可以通过使用少量的年轻一代来最小化年轻一代的停顿，但会降低吞吐量。一代的大小不会影响另一一代的收集频率和暂停时间。</p><p>没有选择世代大小的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可以被“ 调整世代大小” 部分中介绍的命令行选项所覆盖。</p><h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><p>吞吐量和占用空间最好使用特定于应用程序的指标来衡量。例如，可以使用客户端负载生成器来测试Web服务器的吞吐量，而可以使用以下pmap命令在Solaris操作系统上测量服务器的占用空间。但是，通过检查虚拟机本身的诊断输出，很容易估计由于垃圾收集而引起的暂停。</p><p>命令行选项-verbose:gc使有关堆和垃圾收集的信息在每个收集处打印。例如，以下是大型服务器应用程序的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC 325407K-&gt;83000K(776768K), 0.2300771 secs]</span><br><span class="line">[GC 325816K-&gt;83372K(776768K), 0.2454258 secs]</span><br><span class="line">[Full GC 267628K-&gt;83769K(776768K), 1.8479984 secs]</span><br></pre></td></tr></table></figure><p>输出显示两个次要集合，然后是一个主要集合。箭头之前和之后的数字（例如，325407K-&gt;83000K从第一行开始）分别指示垃圾回收之前和之后的活动对象的组合大小。在进行次要收集之后，该大小包括一些垃圾（不再存在）但无法回收的对象。这些对象包含在使用期限的代中或从使用期限的代中引用。</p><p>括号中的下一个数字（例如，(776768K)从第一行起）是堆的已提交大小：Java对象可用的空间量，而无需从操作系统请求更多的内存。请注意，此数字仅包括幸存者空间之一。除了在垃圾回收期间，在任何给定时间仅将使用一个幸存空间来存储对象。</p><p>该行的最后一项（例如0.2300771 secs）指示执行收集所需的时间，在这种情况下约为四分之一秒。</p><p>第三行中主要收藏的格式相似。</p><p>命令行选项将-XX:+PrintGCDetails导致有关集合的其他信息被打印。-XX:+PrintGCDetails此处显示了使用串行垃圾收集器的输出示例。</p><p>[GC [DefNew: 64575K-&gt;959K(64576K), 0.0457646 secs] 196016K-&gt;133633K(261184K), 0.0459067 secs]<br>这表明未成年人的收集恢复了约98％的年轻一代，DefNew: 64575K-&gt;959K(64576K)并花了0.0457646 secs大约45毫秒的时间。</p><p>整个堆的使用减少到了约51％（196016K-&gt;133633K(261184K)），并且收集的最后开销为，稍微增加了一些额外的开销（年轻一代的收集之外）0.0459067 secs。</p><p>该选项-XX:+PrintGCTimeStamps在每个收集开始时添加一个时间戳。这对于查看垃圾收集发生的频率很有用。</p><p>111.042: [GC 111.042: [DefNew: 8128K-&gt;8128K(8128K), 0.0000505 secs]111.042: [Tenured: 18154K-&gt;2311K(24576K), 0.1290354 secs] 26282K-&gt;2311K(32704K), 0.1293306 secs]<br>收集开始到应用程序执行大约111秒。次要收集大约在同一时间开始。此外，还显示了Tenured所描绘的主要收藏的信息。长期使用的使用率降低到约10％（18154K-&gt;2311K(24576K)），并花费了0.1290354 secs大约130毫秒的时间。</p><h1 id="调整分代大小"><a href="#调整分代大小" class="headerlink" title="调整分代大小"></a>调整分代大小</h1><p>许多参数会影响世代大小。“堆参数”说明了堆中已提交空间和虚拟空间之间的差异。在虚拟机初始化时，将保留堆的整个空间。可用-Xmx选项指定保留空间的大小。如果-Xms参数的值小于参数的值，则-Xmx并非所有保留的空间都会立即提交给虚拟机。在此图中，未使用的空间标记为“虚拟”。堆的不同部分（使用权的一代和年轻一代）可以根据需要增长到虚拟空间的极限。</p><p>一些参数是堆的一部分与另一部分的比率。例如，该参数NewRatio表示保有权代与年轻代的相对大小。<br><img src="/images/jsgct_dt_006_prm_gn_sz.png" alt=""></p><p>以下是有关服务器应用程序堆大小的一般准则：</p><ul><li>除非您在暂停方面遇到问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。</li><li>通过从虚拟机中删除最重要的大小决策，将-Xms和设置-Xmx为相同的值可以提高可预测性。但是，如果选择不当，虚拟机将无法补偿。</li><li>通常，由于分配可以并行化，因此随着处理器数量的增加而增加内存。</li></ul><h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2><p>在总可用内存之后，影响垃圾收集性能的第二大影响因素是专用于年轻一代的堆的比例。年轻一代越大，收藏的次数就越少。但是，对于有限的堆大小，较大的年轻代意味着较小的终身代，这将增加主要集合的频率。最佳选择取决于应用程序分配的对象的生命周期分布。</p><p>默认情况下，年轻代大小由参数控制NewRatio。例如，设置-XX:NewRatio=3意味着年轻一代和终身一代之间的比率为1：3。换句话说，伊甸园空间和幸存者空间的总大小将是堆总大小的四分之一。</p><p>这些参数NewSize和MaxNewSize边界从下到上的年轻代大小。这些设置为相同的值修正的年轻一代，就像设置-Xms和-Xmx相同的值修正总堆大小。这对于以比允许的整数倍更好的粒度调整年轻一代很有用NewRatio。</p><h2 id="幸存者空间大小"><a href="#幸存者空间大小" class="headerlink" title="幸存者空间大小"></a>幸存者空间大小</h2><p>您可以使用参数SurvivorRatio来调整幸存空间的大小，但这对于性能通常并不重要。例如，-XX:SurvivorRatio=6将伊甸园和幸存者空间之间的比例设置为1：6。换句话说，每个幸存者空间将是伊甸园大小的六分之一，因此是年轻一代的八分之一（而不是七分之一，因为有两个幸存者空间）。</p><p>如果幸存者空间太小，则复制集合会直接溢出到终身代。如果幸存者空间太大，它们将毫无用处。在每次垃圾回收时，虚拟机都会选择一个阈值数，该阈值数是对象在使用权之前可以复制的次数。选择该阈值可使幸存者半满。命令行选项-XX:+PrintTenuringDistribution（并非在所有垃圾收集器上都可用）可用于显示此阈值和新一代对象的寿命。这对于观察应用程序的生命周期分布也很有用。</p><p>年轻代的最大大小将根据总堆的最大大小和NewRatio参数值来计算。参数的“不受限制”默认值MaxNewSize表示，MaxNewSize除非MaxNewSize在命令行上指定的值，否则计算值不受限制。</p><p>以下是服务器应用程序的一般准则：</p><ul><li>首先确定您可以负担得起的虚拟机的最大堆大小。然后针对年轻一代绘制性能指标，以找到最佳设置。<blockquote><blockquote><p>请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面错误和崩溃。</p></blockquote></blockquote></li><li>如果总堆大小是固定的，则增加年轻代的大小需要减少保有代的大小。使使用期限的一代足够大，以容纳应用程序在任何给定时间使用的所有实时数据，以及一定数量的闲置空间（10％到20％或更多）。</li><li><p>遵循先前对终身代的约束：</p><ul><li>给年轻代留下很多内存。</li><li>随着处理器数量的增加，可以增加年轻代的大小，因为分配可以并行化</li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1></li></ul><p>串行收集器使用单个线程来执行所有垃圾收集工作，这使之相对高效，因为线程之间没有通信开销。它最适合单处理器计算机，因为它不能利用多处理器硬件，尽管它在多处理器上对于数据集较小（大约100 MB）的应用很有用。默认情况下，在某些硬件和操作系统配置上选择了串行收集器，或者可以使用选项显式启用串行收集器-XX:+UseSerialGC。</p><p>并行收集器（也称为吞吐量收集器）并行执行次要收集，这可以大大减少垃圾收集的开销。它适用于具有在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。默认情况下，在某些硬件和操作系统配置上选择了并行收集器，或者可以使用选项显式启用并行收集器-XX:+UseParallelGC。</p><p>并行压缩是使并行收集器能够并行执行主要收集的功能。如果没有并行压缩，则使用单个线程执行主要集合，这会大大限制可伸缩性。如果-XX:+UseParallelGC指定了该选项，则默认情况下启用并行压缩。将其关闭的选项是-XX:-UseParallelOldGC。</p><p>大多数并发的收集器会同时执行其大部分工作（例如，在应用程序仍在运行时），以使垃圾收集暂停时间较短。它设计用于具有中型到大型数据集的应用程序，在这些应用程序中，响应时间比整体吞吐量更重要，因为用于最小化暂停的技术会降低应用程序性能。Java HotSpot VM提供了两个主要是并发收集器之间的选择。使用该选项-XX:+UseConcMarkSweepGC启用CMS收集器或-XX:+UseG1GC启用G1收集器。</p><h2 id="选择收集器"><a href="#选择收集器" class="headerlink" title="选择收集器"></a>选择收集器</h2><p>除非您的应用程序有非常严格的暂停时间要求，否则请先运行您的应用程序并允许VM选择收集器。如有必要，请调整堆大小以提高性能。如果性能仍然不能达到您的目标，请使用以下准则作为选择收集器的起点。</p><ul><li>如果应用程序的数据集较小（最大约100 MB），则使用选项选择串行收集器-XX:+UseSerialGC。</li><li>如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则让VM选择收集器，或使用选项选择串行收集器-XX:+UseSerialGC。</li><li>如果吞吐量是第一要务，并且没有暂停时间要求或可接受的暂停时间为1秒或更长时间，则让VM选择收集器，或使用选择并行收集器-XX:+UseParallelGC。</li></ul><p>如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须保持小于1秒，那么请使用-XX:+UseConcMarkSweepGC或选择并发收集器-XX:+UseG1GC。</p><p>这些准则仅提供选择收集器的起点，因为性能取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度。暂停时间对这些因素特别敏感，因此前面提到的1秒阈值仅是近似值：在许多数据大小和硬件组合上，并行收集器的暂停时间将超过1秒。相反，在某些组合上，并发收集器可能无法将暂停时间保持在1秒以内。</p><p>如果推荐的收集器未达到所需的性能，请首先尝试调整堆和世代大小以满足所需的目标。如果性能仍然不足，请尝试使用其他收集器：使用并发收集器减少暂停时间，并使用并行收集器增加多处理器硬件上的总体吞吐量。</p><h1 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h1><p>并行收集器（在此也称为吞吐量收集器）是类似于串行收集器的分代收集器。主要区别在于使用多个线程来加速垃圾回收。并行收集器通过命令行选项启用-XX:+UseParallelGC。默认情况下，使用此选项，次要和主要收集都将并行执行，以进一步减少垃圾收集的开销。</p><p>上与机器Ñ硬件线程其中Ñ大于8，并行收集器使用的一个固定分数Ñ作为垃圾收集线程的数量。对于较大的N值，该分数约为5/8 。当N的值小于8时，使用的数字为N。在选定的平台上，该分数下降到5/16。垃圾回收器线程的特定数量可以使用命令行选项进行调整（稍后说明）。在具有一个处理器的主机上，由于并行执行（例如，同步）所需的开销，并行收集器的性能可能不如串行收集器。但是，当运行具有中型到大型堆的应用程序时，在具有两个处理器的机器上，它通常比串行收集器的性能要适度，并且在可用两个以上处理器的情况下，其性能通常明显好于串行收集器。</p><p>垃圾收集器线程的数量可以通过命令行选项控制 -XX:ParallelGCThreads=<N>。如果使用命令行选项对堆进行显式调整，则并行收集器要获得良好性能所需的堆大小与串行收集器所需的堆大小相同。但是，启用并行收集器应缩短收集暂停时间。因为多个垃圾收集器线程正在参与次要收集，所以由于收集期间从年轻一代到终身代的晋升，可能会产生一些碎片。次要收集中涉及的每个垃圾收集线程都保留使用权的一代中的一部分进行提升，并且将可用空间划分为这些“提升缓冲区”会导致碎片效应。</p><p>默认情况下，在服务器级计算机上选择并行收集器。此外，并行收集器使用一种自动调整的方法，该方法允许您指定特定的行为，而不是生成大小和其他低级调整详细信息。您可以指定最大的垃圾收集暂停时间，吞吐量和占用空间（堆大小）。</p><p>最大垃圾回收暂停时间：最大暂停时间目标是通过命令行选项指定的-XX:MaxGCPauseMillis=<N>。这被解释为需要<N>毫秒或更少的暂停时间的提示。默认情况下，没有最大暂停时间目标。如果指定了暂停时间目标，则会调整堆大小和与垃圾回收相关的其他参数，以使垃圾回收的暂停时间短于指定值。这些调整可能导致垃圾收集器降低应用程序的整体吞吐量，并且无法始终满足所需的暂停时间目标。</p><p>吞吐量：吞吐量目标是根据进行垃圾收集所花费的时间与在垃圾收集之外所花费的时间（称为应用程序时间）来衡量的。该目标由命令行选项指定，该选项-XX:GCTimeRatio=<N>将垃圾回收时间与应用程序时间之比设置为1 / (1 + <N>)。</p><p>例如，-XX:GCTimeRatio=19将垃圾收集的目标设置为总时间的1/20或5％。默认值为99，导致垃圾回收的目标时间为1％。</p><p>足迹：最大堆足迹使用选项指定-Xmx<N>。另外，收集器还有一个隐含的目标，即只要满足其他目标，就将堆的大小最小化。</p><p>目标优先<br>按照以下顺序解决目标：</p><ul><li>最大暂停时间目标</li><li>吞吐量目标</li><li>最小足迹目标</li></ul><p>首先达到最大暂停时间目标。只有在达到目标之后，才能实现吞吐量目标。同样，只有在达到前两个目标后，才会考虑足迹目标。</p><h2 id="世代大小调整"><a href="#世代大小调整" class="headerlink" title="世代大小调整"></a>世代大小调整</h2><p>收集器保留的统计信息（例如平均暂停时间）将在每个收集结束时更新。然后进行确定目标是否达到的测试，并对世代大小进行任何必要的调整。唯一的例外是，System.gc()在保留统计信息和调整世代大小方面，会忽略显式垃圾回收（例如对的调用）。</p><p>增长和缩小世代的大小是通过增加作为世代大小的固定百分比来完成的，以便使世代朝其期望的大小递增或递减。生长和收缩以不同的速率进行。默认情况下，世代以20％的增量增长，而以5％的增量萎缩。成长百分比由-XX:YoungGenerationSizeIncrement=<Y>年轻一代和-XX:TenuredGenerationSizeIncrement=<T>终身代的命令行选项控制。世代缩小的百分比由命令行标志调整-XX:AdaptiveSizeDecrementScaleFactor=<D>。如果增长增量为X百分比，则收缩的减少量为X / D百分比。</p><p>如果收集器决定在启动时增加一代，则将增加一个补充百分比。这种补充随着收集的数量而衰减，并且没有长期影响。补充的目的是提高启动性能。缩小百分比没有补充。</p><p>如果没有达到最大暂停时间目标，则一次仅缩小一代的大小。如果两个世代的暂停时间都超过了目标，则首先缩减具有较大暂停时间的世代的大小。</p><p>如果未达到吞吐量目标，则两代产品的尺寸都会增加。每一个都按其对总垃圾收集时间的贡献成比例地增加。例如，如果年轻一代的垃圾收集时间为总收集时间的25％，并且如果年轻一代的全部增量将增加20％，则年轻一代将增加5％。</p><h2 id="默认堆大小"><a href="#默认堆大小" class="headerlink" title="默认堆大小"></a>默认堆大小</h2><p>除非在命令行上指定了初始堆大小和最大堆大小，否则它们将根据计算机上的内存量进行计算。</p><h2 id="客户端JVM默认的初始和最大堆大小"><a href="#客户端JVM默认的初始和最大堆大小" class="headerlink" title="客户端JVM默认的初始和最大堆大小"></a>客户端JVM默认的初始和最大堆大小</h2><p>默认最大堆大小是物理内存的一半，最大物理内存大小为192兆字节（MB），否则，四分之一的物理内存，最大物理内存大小为1 GB。</p><p>例如，如果您的计算机具有128 MB的物理内存，则最大堆大小为64 MB，并且大于或等于1 GB的物理内存将导致最大堆大小为256 MB。</p><p>除非您的程序创建了足够多的对象来要求它，否则JVM实际上并没有使用最大堆大小。在JVM初始化期间分配了一个较小的值，称为初始堆大小。该数量至少为8 MB，否则为物理内存的1/64，最大为1 GB。</p><p>分配给年轻代的最大空间量是总堆大小的三分之一。</p><h2 id="服务器JVM默认的初始和最大堆大小"><a href="#服务器JVM默认的初始和最大堆大小" class="headerlink" title="服务器JVM默认的初始和最大堆大小"></a>服务器JVM默认的初始和最大堆大小</h2><p>默认的初始堆大小和最大堆大小在服务器JVM上的工作方式与在客户端JVM上的工作方式类似，不同之处在于，默认值可以更高。在32位JVM上，如果有4 GB或更多的物理内存，则默认的最大堆大小最多可以为1 GB。在64位JVM上，如果有128 GB或更多的物理内存，则默认的最大堆大小最大为32 GB。您始终可以通过直接指定这些值来设置更高或更低的初始堆和最大堆；请参阅下一节。</p><h2 id="指定初始和最大堆大小"><a href="#指定初始和最大堆大小" class="headerlink" title="指定初始和最大堆大小"></a>指定初始和最大堆大小</h2><p>您可以使用标志-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。如果你知道你的应用程序有多少堆需要工作做好，你可以设置-Xms和-Xmx相同的值。否则，JVM将使用初始堆大小开始，然后将增大Java堆，直到找到堆使用和性能之间的平衡为止。</p><p>其他参数和选项可能会影响这些默认值。要验证您的默认值，请使用该-XX:+PrintFlagsFinal选项并MaxHeapSize在输出中查找。例如，在Linux或Solaris上，可以运行以下命令：</p><p>java -XX：+ PrintFlagsFinal &lt;GC选项&gt;-版本 | grep MaxHeapSize<br>过多的GC时间和OutOfMemoryError<br>并行收集器会OutOfMemoryError在垃圾回收（GC）上花费过多的时间：如果在垃圾回收中花费了总时间的98％以上，而回收不到2％的堆，则OutOfMemoryError抛出。此功能旨在防止应用程序长时间运行，而由于堆太小而几乎没有进展，甚至没有进展。如有必要，可以通过-XX:-UseGCOverheadLimit在命令行中添加选项来禁用此功能。</p><h2 id="Java-Hotspot-VM在JDK-8中有两个主要的并发收集器："><a href="#Java-Hotspot-VM在JDK-8中有两个主要的并发收集器：" class="headerlink" title="Java Hotspot VM在JDK 8中有两个主要的并发收集器："></a>Java Hotspot VM在JDK 8中有两个主要的并发收集器：</h2><p>并发标记扫描（CMS）收集器：此收集器用于那些希望更短的垃圾收集暂停并能够与垃圾收集共享处理器资源的应用程序。</p><p>垃圾优先的垃圾收集器(G1)：此服务器样式的收集器用于具有大内存的多处理器计算机。它在实现高吞吐量的同时极有可能满足垃圾收集暂停时间目标。</p><p>大多数并发的收集器以处理器资源（否则应用程序可以使用）为代价，以缩短主要的收集暂停时间。最明显的开销是在集合的并发部分使用一个或多个处理器。在N个处理器系统上，集合的并发部分将使用可用处理器的K / N，其中1 &lt;= K &lt;= ceiling { N / 4}。（请注意，对K的精确选择和范围可能会发生变化。）除了在并发阶段使用处理器外，还会产生额外的开销来实现并发。因此，虽然并发收集器的垃圾收集暂停通常要短得多，但应用程序吞吐量也往往比其他收集器要低一些。</p><p>在具有多个处理核心的机器上，处理器在收集的并发部分可用于应用程序线程，因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致更短的暂停时间，但是再次有较少的处理器资源可用于应用程序，并且应该会出现一些减慢的情况，尤其是在应用程序最大程度地使用所有处理核心的情况下。随着N的增加，由于并发垃圾收集而导致的处理器资源减少将变得更小，并且并发收集的收益也会增加。的部分并行模故障在并发标记扫描（CMS）集电极讨论了这样的缩放潜在限制。</p><p>因为在并发阶段使用至少一个处理器进行垃圾收集，所以并发收集器通常不会在单处理器（单核）计算机上提供任何好处。但是，有一种适用于CMS的单独模式（非G1）可以在只有一个或两个处理器的系统上实现低暂停。看到增量模式在并发标记扫描（CMS）收集器的详细信息。Java SE 8中不推荐使用此功能，以后的主要版本中可能会删除该功能。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp流量控制及拥塞控制</title>
      <link href="2017/06/20/develop/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>2017/06/20/develop/tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="什么是流量控制？其目的是什么？"><a href="#什么是流量控制？其目的是什么？" class="headerlink" title="什么是流量控制？其目的是什么？"></a>什么是流量控制？其目的是什么？</h2><p>tcp是面向连接的通信协议，建立连接之后两端才发送数据，如果发送方发送数据过快，导致接收方来不及接受，那么多处的部分就会丢失。为了避免这个情况，就需要控制发送方的发送速度，使得接收方可以完全接收，这个就是流量控制。流量控制的目的就是防止分组丢失，它是构成TCP可靠性的一方面。</p><span id="more"></span><h2 id="流量控制的实现"><a href="#流量控制的实现" class="headerlink" title="流量控制的实现"></a>流量控制的实现</h2><p>由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的ACK中会包含自己的接收窗口大小，并且利用大小来控制发送方的数据发送。</p><h2 id="流量控制引发的死锁及如何避免"><a href="#流量控制引发的死锁及如何避免" class="headerlink" title="流量控制引发的死锁及如何避免"></a>流量控制引发的死锁及如何避免</h2><p>当发送方收到了一个窗口大小为0的应答，发送方便会停止发送，等待接收方的下一个应答。但是如果接收方发送的下一个窗口大小不为0的应答在传输过程中丢失，这就会导致发送方收不到应答而继续保证等待状态，接收方则因为自身已经发送了应答而处于等待数据的接收状态，从而产生了死锁。</p><p>为了避免流量控制导致的死锁，TCP使用了持续计时器。每当发送方收到一个0窗口应答就会启动计时器。时间一到便主动发送报文询问接收方的窗口大小。如果接收方仍返回0窗口，则重置计时器后继续等待；若窗口不为0，则表示应答报文丢失，此时重置发送窗口后开始发送，这样避免了死锁的产生。</p><h1 id="拥塞控制及于流量控制的区别"><a href="#拥塞控制及于流量控制的区别" class="headerlink" title="拥塞控制及于流量控制的区别"></a>拥塞控制及于流量控制的区别</h1><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是</p><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><p>流量控制是作用于接收方的，它是控制发送方的发送速度，防止分组丢失。</p><h1 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h1><p>假设：</p><ul><li>数据是单方向传递，另一个窗口只发送确认</li><li>接收方的缓存足够大<br>因此发送方的大小由网络的拥塞程度来决定。</li></ul><h2 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h2><p>发送方维持一个<strong>拥塞窗口cwnd(congestion window</strong>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化，发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的处理能力，发送窗口可能小于拥塞窗口。</p><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测网络的拥塞程度，也就是说由小到大的逐渐增加拥塞窗口大小。</p><p><img src="/images/v2-54715533f093170d50f1ff1be39006e9_hd.jpg" alt=""><br><em>这里用报文个数作为拥塞窗口大小，实际上是字节为单位</em></p><p>从图中可以看出，一个传输轮次所经历的时间就是往返时间RTT，而且每经过一个轮次，<strong>拥塞窗口cwnd</strong>就会加倍。</p><p>为了防止cwnd增加过大引起网络拥塞，还需要设置一个<strong>慢开始门限ssthres</strong>状态变量。ssthres的用法如下：</p><ul><li><code>cwnd &lt; ssthresh</code>，使用慢开始算法</li><li><code>cwnd &gt; ssthresh</code>，改用拥塞避免算法</li><li><code>cwnd = ssthresh</code>，任意选择</li></ul><h2 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h2><p>拥塞避免算法可以让拥塞窗口缓慢增长，即每经过一个往返时间RTT，就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性缓慢增加。</p><p>无论是在慢开始阶段还是慢拥塞避免阶段，只要发送方判断网络出现拥塞（<em>其根据就是没有按时收到确认</em>），虽然没有收到确认的原因可能是分组丢失，但因为无法判定，所以都按照拥塞来处理，把慢开始门限ssthresh设置为出现拥塞时发送窗口的一半（<em>不能小于2</em>）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。<br><img src="/images/v2-f7db63b1f00cbd8170e1435616e06216_hd.jpg" alt=""></p><h2 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h2><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（<em>为的是使发送方及早知道有报文没有达到，可提高网络吞吐量约20%</em>），而不是等到自己发送数据时捎带确认，快速重传算法规定：发送方只要一连收到三个重复确认就应该立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。</p><p><img src="/images/v2-c72fce5494ca8ee12244189430f12cea_hd.jpg" alt=""><br>如图所示，在发送方发送了M3之后，在传输过程中丢失报文，对于之后发送的报文，接收方都是发送ack M2的应答，在三次重复确认应答后，发送方知道了M3报文丢失，所以之后立即重传M3。</p><h2 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h2><p>快重传配合使用的还有快恢复算法。当发送方连续收到三个重复确认应答时，就执行<strong>乘法减小</strong>算法，把ssthresh门限减半（<em>为了预防网络发生拥塞</em>）。但是接下去并不执行慢开始算法。考虑到如果网络出现拥塞的话就不会出现好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。</p><p><img src="/images/v2-5f4034bc11c3a48a1d1a115f9ee0259b_hd.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cap定理</title>
      <link href="2016/12/15/develop/cap/"/>
      <url>2016/12/15/develop/cap/</url>
      
        <content type="html"><![CDATA[<p>分布式最大的难点就是各个服务器间的同步，保持各个节点的一致性，cap定理就是这方面的基本定理。CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的，所以我们只能在一致性和可用性之间进行权衡</p><span id="more"></span><h1 id="分布式系统的三个指标"><a href="#分布式系统的三个指标" class="headerlink" title="分布式系统的三个指标"></a>分布式系统的三个指标</h1><p><img src="/images/bg2018071607.jpg" alt=""></p><p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时C和P两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了CP系统，但是CAP不可同时满足 。<br>因此在进行分布式架构设计时，必须做出取舍。当前一般是通过分布式缓存中各节点的最终一致性来提高系统的性能，通过使用多节点之间的数据异步复制技术来实现集群化的数据一致性。</p><h1 id="Partition-Tolerance-分区容忍性"><a href="#Partition-Tolerance-分区容忍性" class="headerlink" title="Partition Tolerance(分区容忍性)"></a>Partition Tolerance(分区容忍性)</h1><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。<br><img src="/images/bg2018071601.png" alt=""><br>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。<br>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><h1 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency(一致性)"></a>Consistency(一致性)</h1><p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。<br><img src="/images/bg2018071602.png" alt=""><br>接下来，用户的读操作就会得到 v1。这就叫一致性。<br><img src="/images/bg2018071603.png" alt=""><br>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了<br><img src="/images/bg2018071604.png" alt=""><br>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。<br><img src="/images/bg2018071605.png" alt=""><br>这样的话，用户向 G2 发起读操作，也能得到 v1<br><img src="/images/bg2018071606.png" alt=""></p><h1 id="Avaliability-可用性"><a href="#Avaliability-可用性" class="headerlink" title="Avaliability(可用性)"></a>Avaliability(可用性)</h1><p>客户端向其成功发送请求，服务器必须给与响应，用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性</p><h1 id="Consistency-与-Avaliable的矛盾"><a href="#Consistency-与-Avaliable的矛盾" class="headerlink" title="Consistency 与 Avaliable的矛盾"></a>Consistency 与 Avaliable的矛盾</h1><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。</p><p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p><p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC</title>
      <link href="2016/12/15/develop/rpc/"/>
      <url>2016/12/15/develop/rpc/</url>
      
        <content type="html"><![CDATA[<p>RPC即远程过程调用（Remote Produce Call），是一个计算机通信协议，该协议允许一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外的为这个交互编程。</p><span id="more"></span><p>在业内有很多流行的RPC框架，如Dubbo提供的是基于接口的远程方法调用，grpc基于协议的接口方法调用，即客户端只需要知道接口的定义即可调用远程服务。在Java中并不能直接调用实例方法，必须通过实现类对象来完成此操作，这就意味着客户端必须为这些接口生成<strong>代理对象</strong>，对此Java提供了Proxy，InvocationHandler生成动态代理的方式，并在InvocationHandler中实现invoke方法，完成远程调用的结果。</p><p>远程调用就是两台主机间的网络通信，涉及到网络通信必然会有序列化，反序列化，编解码等步骤；同时对于现在系统而言都是集群部署，所以还需要管理服务列表，这就涉及到注册中心，由注册中心统一管理服务列表；有了注册中心，客户端需要通过某些策略从注册中心来查找服务，就是所谓的服务发现。</p><p>RPC服务端就是定义接口的真正实现，监听指定的接口从网络请求中读取参数，再根据请求参数通过反射等形式调用接口的实现获取结果，并将结果写入对应的响应流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">client                                 register center                      server</span><br><span class="line"></span><br><span class="line">  |       注册服务接口 -&gt;                        |           &lt;-注册服务接口      |     </span><br><span class="line">  |       初始化并拉取服务列表 -&gt;                 |</span><br><span class="line">  |       服务上下线通知(主动，被动)     -&gt;       |</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  |      通过负载策略，选择其中一个服务的实例</span><br><span class="line">  |      调用接口后将接口及参数等封装成一个任务并放入任务池</span><br><span class="line">  |      请求连接池</span><br><span class="line">  |      序列化，编码，发送请求                     --&gt;                           |</span><br><span class="line">  |                                                                          收到请求后反序列化&#x2F;解码</span><br><span class="line">  |                                                                          从请求中解析出参数方法，查找到具体实现的类方法（方法缓存，限流等操作）</span><br><span class="line">  |                                              &lt;--                        方法调用结果，并结果序列化，编码   </span><br><span class="line">  |       反序列化，解码，解析得到结果                              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之背包问题</title>
      <link href="2016/05/26/develop/knapsack/"/>
      <url>2016/05/26/develop/knapsack/</url>
      
        <content type="html"><![CDATA[<p>我们有一个背包，最多装20kg，现在有三种物品，重量分别是{3kg，8kg，15kg}，问如何组装能使得物品被最多的装进背包。</p><span id="more"></span><p>对于这类问题，可以统一称为 0/1背包问题，这个问题属于简化版，没有考虑物品的价值，下面我们来看如果解这类问题。首先归溯法（遍历）肯定是可以用，不过性能非常差，数量多，而且中间有很多的重复计算过程，下面我们用<strong>动态规划</strong>来解这类的题目。</p><h1 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h1><p>动态规划主要分成三步，定义状态，初始化，寻找状态转移公式。这里我们定义<code>state[i][j]</code>表示背包容量为<code>j</code>时，装到<code>i</code>个物品时，背包所允许装的物品总量。那么<code>state[2][20]</code>就是我们需要的结果 <em>(因为数组从0开始计算，也可以通过哨兵修改成1开始)</em>。对于处理第<code>i</code>个物品的时候，我们要么放，要么不放，对于不放，那<code>state[i][j] = state[i-1][j]</code>，意思就是上一次的组合情况就是最佳，对于放入则<code>state[i][j] = state[i-1][j-cost[i-1]] + cost[i-1]</code>,<em>（cost表示物品重量的数组）</em>，要注意<strong>state</strong>的定义，对于<code>cost[i-1] &gt; j</code>,这时候肯定是装不下了，所以选择不再装包。所以最终结果是<code>state[i][j] = max(state[i-1][j], state[i-1][j-cost[i-1]]+cost[i-1])</code></p><p>有了这些条件后就可以开始写代码了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int knapsack(int[] cost, int capacity)&#123;</span><br><span class="line">    if(cost &#x3D;&#x3D; null || capacity &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int m &#x3D; cost.length;</span><br><span class="line">    int n &#x3D; capacity;</span><br><span class="line">    &#x2F;&#x2F;通过哨兵，将数组从索引1开始计算，便于理解</span><br><span class="line">    int[][] state &#x3D; new int[m+1][n+1];</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        for(int j&#x3D;n;j&gt;0;j--)&#123;</span><br><span class="line">            &#x2F;&#x2F;第i个物品超过了当前容量</span><br><span class="line">            if(cost[i-1] &gt; j)&#123;</span><br><span class="line">                state[i][j] &#x3D; state[i-1][j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                state[i][j] &#x3D; Math.max(state[i-1][j], state[i-1][j-cost[i-1]]+cost[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return state[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>这个算法空间与时间的复杂度是<code>m*n</code>,从过程中可以看出，state都只是依赖于上一过程的结果，所以空间上可以优化到n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int knapsack(int[] cost, int capacity)&#123;</span><br><span class="line">    if(cost &#x3D;&#x3D; null || capacity &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int m &#x3D; cost.length;</span><br><span class="line">    int n &#x3D; capacity;</span><br><span class="line">    &#x2F;&#x2F;通过哨兵，将数组从索引1开始计算，便于理解</span><br><span class="line">    in[] state &#x3D; new int[n+1];</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">        for(int j&#x3D;n;j&gt;0;j--)&#123;</span><br><span class="line">            &#x2F;&#x2F;第i个物品超过了当前容量</span><br><span class="line">            if(cost[i-1] &gt; j)&#123;</span><br><span class="line">                state[j] &#x3D; state[j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                state[j] &#x3D; Math.max(state[j], state[j-cost[i-1]]+cost[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return state[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcp三次握手及四次挥手</title>
      <link href="2016/05/18/develop/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>2016/05/18/develop/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><span id="more"></span><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：</p><ul><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。</li></ul><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><ul><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li></ul><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><ul><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li></ul><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><p><img src="/images/16da9fd28a45bd19.jpg" alt=""></p><h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><p>第一次握手：客户端发送网络包，服务端收到了。<br>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。<br>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。<br>第三次握手：客户端发包，服务端收到了。<br>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。<br>试想如果是用两次握手，则会出现下面这种情况：</p><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h2 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。<br>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。<br>这里在补充一点关于SYN-ACK 重传次数的问题：<br>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。<br>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p><h2 id="ISN-Initial-Sequence-Number"><a href="#ISN-Initial-Sequence-Number" class="headerlink" title="ISN(Initial Sequence Number)"></a>ISN(Initial Sequence Number)</h2><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p><p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h2 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h2><p>其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据<br>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。<br>也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。<br>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。<br><code>netstat -n -p TCP | grep SYN_RECV</code></p><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。<br>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li></ul><p>即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><ul><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li></ul><p>即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><ul><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li></ul><p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><ul><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li></ul><p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p><p>收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</p><p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="/images/16da9fd28b49f652.jpg" alt=""></p><h2 id="挥手为什么需要四次"><a href="#挥手为什么需要四次" class="headerlink" title="挥手为什么需要四次"></a>挥手为什么需要四次</h2><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h2 id="2MSL等待状态"><a href="#2MSL等待状态" class="headerlink" title="2MSL等待状态"></a>2MSL等待状态</h2><p>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。<br>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。<br>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><h2 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义"></a>四次挥手释放连接时，等待2MSL的意义</h2><blockquote><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p>两个理由：</p><ul><li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li></ul><p>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</p><ul><li>防止“已失效的连接请求报文段”出现在本连接中。</li></ul><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p><h2 id="为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态"><a href="#为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态"></a>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态</h2><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/16da9fd28b1900f9.jpg" alt=""><br>《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
